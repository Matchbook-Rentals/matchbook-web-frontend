This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
components/
  ConversationHeader.tsx
  ConversationList.tsx
  MessageArea.tsx
  MessageInputArea.tsx
  MessageList.tsx
message-area-refactor.md
message-interface.tsx
message-route-briefing.md
page.tsx
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="components/ConversationHeader.tsx">
import React from 'react';
import { ArrowLeftIcon } from 'lucide-react';
import { Dialog, DialogContent, DialogHeader, DialogTrigger } from "@/components/ui/dialog";
import { Button } from '@/components/ui/button';
import { UserRating } from '@/components/reviews/host-review';

interface ConversationHeaderProps {
  selectedConversation: any;
  participantInfo: {
    displayName: string;
    imageUrl: string;
  };
  onBack?: () => void;
  isMobile: boolean;
  handleBackClick: () => void;
}

const ConversationHeader: React.FC<ConversationHeaderProps> = ({
  selectedConversation,
  participantInfo,
  onBack,
  isMobile,
  handleBackClick
}) => {
  return (
    <div className='h-[72px] border-b-2 flex items-center pr-2'>
      {selectedConversation ? (
        <div className="w-full relative flex justify-between items-center ">
        <div className='flex space-x-4'>
          {onBack && (
            <button
              onClick={handleBackClick}
              className="md:hidden ml-4 rounded-full bg-transparent"
            >
              <ArrowLeftIcon size={24} />
            </button>
          )}
          <div className="flex items-center justify-center w-fit md:justify-start md:pl-[calc(2.5vw+7px)]">
            <img
              src={participantInfo.imageUrl}
              alt={participantInfo.displayName}
              className="w-12 h-12 aspect-square rounded-full object-cover mr-4"
            />
            <div className="flex justify-between w-full gap-4">
              <p className="overflow-hidden text-[#212121] max-w-[200px] md:max-w-[500px] truncate text-base sm:text-lg md:text-xl lg:text-[18px] font-medium leading-tight">
                {participantInfo.displayName}
              </p>
            </div>
          </div>
          </div>

          <Dialog>
            <DialogTrigger>
              <Button>
                Show Review
              </Button>
            </DialogTrigger>
            <DialogContent className=''>
              <DialogHeader className='pl-[5%] w-full mx-auto'>
                <p className='text-center font-medium text-lg'>
                  Reviews for {participantInfo.displayName}
                </p>
              </DialogHeader>
              <UserRating avatarImgUrl={participantInfo.imageUrl} />
            </DialogContent>
          </Dialog>
        </div>
      ) : (
        <div className="bg-blueBrand/10 w-full mx-auto p-4 flex items-center md:hidden shadow-md">
          {onBack && isMobile && (
            <button
              onClick={handleBackClick}
              className="md:hidden flex items-center justify-center p-2 rounded-full bg-transparent"
            >
              <ArrowLeftIcon size={20} />
            </button>
          )}
          <div className="w-full text-center font-medium">
            Select a conversation
          </div>
        </div>
      )}
    </div>
  );
};

export default ConversationHeader;
</file>

<file path="components/ConversationList.tsx">
import React, { useState } from 'react';
import { Conversation } from '@prisma/client';
import { UserResource } from '@clerk/types';
import { Button } from '@/components/ui/button';
import { ChevronDown, Inbox, Home, Key, HeadphonesIcon } from 'lucide-react';
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import { ScrollArea } from "@/components/ui/scroll-area";

// Define the conversation participant structure
interface ConversationParticipant {
  id: string;
  userId: string;
  conversationId: string;
  joinedAt: Date;
  leftAt: Date | null;
  role: string;
  User: {
    id: string;
    firstName: string | null;
    lastName: string | null;
    email: string | null;
    imageUrl: string | null;
  };
}

// Define the extended conversation type
interface ExtendedConversation extends Conversation {
  messages: any[];
  participants: ConversationParticipant[];
  isUnread: boolean;
  listing?: {
    id: string;
    title: string;
  };
}

interface ConversationListProps {
  conversations: ExtendedConversation[];
  onSelectConversation: (conversationId: string) => void;
  onCreateConversation: (email: string) => void;
  user: UserResource;
  onTabChange?: (tab: string) => void;
  activeTab?: string;
  selectedConversationId?: string;
}

const ConversationList: React.FC<ConversationListProps> = ({
  conversations,
  onSelectConversation,
  onCreateConversation,
  user,
  onTabChange,
  activeTab = 'all',
  selectedConversationId
}) => {
  const [searchTerm, setSearchTerm] = useState('');
  const [showUnreadOnly, setShowUnreadOnly] = useState(false);
  const [open, setOpen] = useState(false);

  const toggleUnreadOnly = () => {
    setShowUnreadOnly(!showUnreadOnly);
  };

  const getParticipantInfo = (conv: ExtendedConversation, currentUser: UserResource) => {
    if (!currentUser) return { displayName: "Loading...", imageUrl: "" };

    // Find the other participant in the conversation
    const otherParticipant = conv.participants.find(
      p => p.User.id !== currentUser.id
    );

    if (!otherParticipant) {
      return { displayName: "Unknown", imageUrl: "" };
    }

    const { User } = otherParticipant;
    let displayName = User.firstName && User.lastName
      ? `${User.firstName} ${User.lastName}`
      : User.email || "Unknown";

    return {
      displayName,
      imageUrl: User.imageUrl || ""
    };
  };

  // Filter conversations based on search term and unread status
  const filteredConversations = conversations
    .filter(conv => {
      const { displayName } = getParticipantInfo(conv, user);
      const matchesSearch = displayName?.toLowerCase().includes(searchTerm.toLowerCase()) || false;

      // If showUnreadOnly is true, filter for conversations with unread messages
      if (showUnreadOnly) {
        // Use the isUnread prop passed down from the parent
        return matchesSearch && conv.isUnread === true;
      }

      return matchesSearch;
    })
    .sort((convA, convB) => {
      const lastMessageA = convA.messages?.[convA.messages.length - 1];
      const lastMessageB = convB.messages?.[convB.messages.length - 1];

      const timeA = lastMessageA ? new Date(lastMessageA.createdAt).getTime() : 0;
      const timeB = lastMessageB ? new Date(lastMessageB.createdAt).getTime() : 0;

      return timeB - timeA; // Sort by most recent message first
    });

  // Helper function to format the timestamp for the last message
  const formatLastMessageTime = (createdAt: string | Date): string => {
    try {
      const date = new Date(createdAt);
      const now = new Date();
      const diff = now.getTime() - date.getTime();
      const hours = diff / (1000 * 60 * 60);

      if (hours < 24) {
        // If less than 24 hours ago, show time
        return date.toLocaleTimeString('en-US', {
          hour: 'numeric',
          minute: '2-digit',
          hour12: true
        });
      } else {
        // If more than 24 hours ago, show date
        return date.toLocaleDateString('en-US', {
          month: 'short',
          day: 'numeric'
        });
      }
    } catch (e) {
      console.log('Date parsing error:', e, createdAt);
      return 'Just now';
    }
  };


  return (
    <div className="h-[calc(100vh-theme(spacing.16))] bg-background flex border-r-2 p-1 pr-2 pt-4 pb-1 md:pr-[2.5vw] min-w-[310px] w-full flex-col overflow-hidden">
      {/* Checkbox styling to ensure black fill when checked */}
      <style jsx>{`
        input[type="checkbox"]:checked {
          background-color: #000 !important;
          border-color: #000 !important;
        }
        input[type="checkbox"]:focus {
          --tw-ring-color: transparent !important;
        }
      `}</style>


      {/* Role Filter and Unread Toggle */}
      <div className="pb-2 text-black">
        <div className="flex items-center space-x-4">
          <Popover open={open} onOpenChange={setOpen}>
            <PopoverTrigger asChild>
              <Button className="bg-black text-white border-black rouned-lg md:rounded-full py-1 px-3 flex items-center gap-2">
                {activeTab === 'all' ? 'All' : activeTab}
                <ChevronDown className="h-4 w-4" />
              </Button>
            </PopoverTrigger>
            <PopoverContent className=" w-[200px] ml-4 p-0 ">
              <div className="flex flex-col">
                <Button
                  variant="ghost"
                  className="justify-start hover:bg-gray-100 rounded-none"
                  onClick={() => {
                    onTabChange?.('all');
                    setOpen(false);
                  }}
                >
                  <Inbox className="mr-4 h-4 w-4" />
                  All
                </Button>
                <Button
                  variant="ghost"
                  className="justify-start  hover:bg-gray-100 rounded-none"
                  onClick={() => {
                    onTabChange?.('Hosting');
                    setOpen(false);
                  }}
                >
                  <Home className="mr-4 h-4 w-4" />
                  Hosting
                </Button>
                <Button
                  variant="ghost"
                  className="justify-start hover:bg-gray-100 rounded-none"
                  onClick={() => {
                    onTabChange?.('Renting');
                    setOpen(false);
                  }}
                >
                  <Key className="mr-4 h-4 w-4" />
                  Renting
                </Button>
                <Button
                  variant="ghost"
                  className="justify-start hover:bg-gray-100 rounded-none"
                  onClick={() => {
                    onTabChange?.('Support');
                    setOpen(false);
                  }}
                >
                  <HeadphonesIcon className="mr-4 h-4 w-4" />
                  Support
                </Button>
              </div>
            </PopoverContent>
          </Popover>

          <div className="flex items-center">
            <input
              type="checkbox"
              id="unreadOnlyCheckbox"
              checked={showUnreadOnly}
              onChange={toggleUnreadOnly}
              className="w-4 h-4 rounded border-gray-300 text-black focus:ring-0 focus:ring-offset-0 mr-2 cursor-pointer accent-black"
            />
            <label htmlFor="unreadOnlyCheckbox" className="text-sm font-medium cursor-pointer select-none">
              Unread Only
            </label>
          </div>
        </div>
      </div>

      {/* Search Bar */}
      <div className="pt-3  pb-4">
        <div className="relative">
          <div className="absolute inset-y-0 left-0 flex items-center pl-3 pointer-events-none">
            <svg className="w-5 h-5 text-gray-500" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path>
            </svg>
          </div>
          <input
            type="text"
            placeholder="Search Messages"
            className="w-full p-2 pl-10 rounded-[15px] bg-gray-100 border-gray-400 text-black focus:outline-none focus:ring-1 focus:ring-black"
            value={searchTerm}
            onChange={(e) => setSearchTerm(e.target.value)}
          />
        </div>
      </div>

      {/* Conversation List */}
      <ScrollArea className="flex-1 py-2 w-[100%] md:w-[110%] pr-2 md:pr-8 pb-2 md:pb-6">
        {filteredConversations && filteredConversations.length > 0 ? (
          filteredConversations.map((conv, index) => {
            const { displayName, imageUrl } = getParticipantInfo(conv, user);
            const lastMessage = conv.messages && conv.messages.length > 0
              ? conv.messages[conv.messages.length - 1]
              : null;

            return (
              <div
                key={conv.id}
                className={`w-full mb-3 rounded-lg cursor-pointer ${selectedConversationId === conv.id ? 'bg-gray-100' : ''} hover:bg-gray-100 transition-shadow duration-200`}
                onClick={() => onSelectConversation(conv.id)}
              >
                <div className="p-3 flex items-center h-full w-full">
                  <div className="relative flex-shrink-0">
                    <img
                      src={imageUrl || "/placeholder-avatar.png"}
                      className="w-11 h-11 aspect-square object-cover rounded-full mr-3"
                      alt={displayName}
                    />
                    {/* Use the isUnread prop for the indicator */}
                    {conv.isUnread && (
                      <div className="absolute top-0 right-2 w-3 h-3 bg-blue-500 rounded-full"></div>
                    )}
                  </div>
                  <div className="flex flex-col justify-between min-w-0 flex-1 h-full py-1">
                    <div className="flex justify-between items-start w-full">
                      <div className="flex flex-col min-w-0 flex-1 mr-2">
                        <span className="font-normal text-sm text-gray-600 truncate">
                          {displayName}
                        </span>
                      </div>
                      <span className="text-xs text-gray-500 flex-shrink-0 whitespace-nowrap">
                        {lastMessage && lastMessage.createdAt ? formatLastMessageTime(lastMessage.createdAt) : ''}
                      </span>
                    </div>
                    <span className={`text-sm font-normal text-gray-600 truncate max-w-[200px]`}>
                      {lastMessage ? (
                        lastMessage.content ? (
                          // Display content if available
                          lastMessage.content
                        ) : lastMessage.fileName ? (
                          // Display filename in italics if content is empty but filename exists
                          <i>{lastMessage.fileName}</i>
                        ) : (
                          // Fallback if content and filename are missing
                          'Attachment'
                        )
                      ) : (
                        // No last message
                        'Start a conversation'
                      )}
                    </span>
                    <span className="text-xs text-gray-600 truncate">
                      {conv.listingId ? (`${conv.listing?.title || "Cozy Downtown Apartment"}`) : "Property Discussion"}
                    </span>
                  </div>
                </div>
              </div>
            );
          })
        ) : (
          <div className="flex flex-col items-center justify-center h-32 text-gray-500">
            <p>No conversations found</p>
          </div>
        )}
      </ScrollArea>
    </div>
  );
};

export default ConversationList;
</file>

<file path="components/MessageArea.tsx">
import React, { useState, useRef, useEffect } from 'react';
import { Download } from 'lucide-react';
import Image from "next/image";
import { Dialog, DialogContent } from "@/components/ui/dialog";
import { FilePreview } from '@/components/ui/file-preview';
import { isImageFile } from '@/lib/utils';
import { ScrollArea } from "@/components/ui/scroll-area";
import { Button } from '@/components/ui/button';
import MessageList from './MessageList';
import MessageInputArea from './MessageInputArea';
import ConversationHeader from './ConversationHeader';

interface MessageAreaProps {
  selectedConversation: any;
  messages: any[];
  onSendMessage: (message: string, attachments?: MessageFile[]) => void;
  currentUserId: string | undefined;
  currentUserImage?: string | null;
  onBack?: () => void;
  onTyping?: (isTyping: boolean) => void;
  isOtherUserTyping?: boolean;
  initialIsMobile?: boolean;
}

interface MessageFile {
  url: string;
  fileName?: string;
  fileKey?: string;
  fileType?: string;
  fileSize?: number;
}

const MessageArea: React.FC<MessageAreaProps> = ({
  selectedConversation,
  messages,
  onSendMessage,
  currentUserId,
  currentUserImage = "/placeholder-avatar.png",
  onBack,
  onTyping,
  isOtherUserTyping = false,
  initialIsMobile = false
}) => {
  const [selectedFile, setSelectedFile] = useState<MessageFile | null>(null);
  const bottomRef = useRef<HTMLDivElement>(null);
  const scrollAreaRef = useRef<HTMLDivElement>(null);
  const [isExiting, setIsExiting] = useState(false);
  const [isMobile, setIsMobile] = useState(initialIsMobile);

  useEffect(() => {
    const checkIfMobile = () => {
      setIsMobile(window.innerWidth < 768);
    };

    checkIfMobile();

    window.addEventListener('resize', checkIfMobile);

    return () => {
      window.removeEventListener('resize', checkIfMobile);
    };
  }, []);

  useEffect(() => {
    if (selectedConversation) {
      setIsExiting(false);
    }
  }, [selectedConversation]);

  const handleBackClick = () => {
    if (!onBack) return;

    if (isMobile) {
      setIsExiting(true);
      setTimeout(() => {
        onBack();
        setTimeout(() => {
          setIsExiting(false);
        }, 100);
      }, 250);
    } else {
      onBack();
    }
  };

  const scrollToBottom = () => {
    if (scrollAreaRef.current && bottomRef.current) {
      const scrollContainer = scrollAreaRef.current.querySelector('[data-radix-scroll-area-viewport]');
      if (scrollContainer) {
        scrollContainer.scrollTop = scrollContainer.scrollHeight;
      }
    }
  };

  useEffect(() => {
    const timer = setTimeout(() => {
      scrollToBottom();
    }, 100);

    return () => clearTimeout(timer);
  }, [messages]);

  const handleFileClick = (file: MessageFile) => {
    // Only open the dialog if the file is an image
    if (file.fileName && isImageFile(file.fileName)) {
      setSelectedFile(file);
    }
    // For non-image files, clicking does nothing in terms of opening the dialog.
    // Download functionality is handled separately by the FilePreview component itself if needed.
  };

  const getParticipantInfo = () => {
    if (!selectedConversation || !selectedConversation.participants) {
      return { displayName: "Unknown", imageUrl: "" };
    }

    const otherParticipant = selectedConversation.participants.find(
      (p: any) => p.User.id !== currentUserId
    );

    if (!otherParticipant) {
      return { displayName: "Unknown", imageUrl: "" };
    }

    const { User } = otherParticipant;
    let displayName = "Unknown";

    if (User.fullName) {
      displayName = User.fullName;
    } else if (User.firstName && User.lastName) {
      displayName = `${User.firstName} ${User.lastName}`;
    } else if (User.firstName || User.lastName) {
      displayName = User.firstName || User.lastName;
    } else if (User.email) {
      displayName = User.email;
    }

    return {
      displayName,
      imageUrl: User.imageUrl || "/placeholder-avatar.png"
    };
  };

  const participantInfo = selectedConversation ? getParticipantInfo() : { displayName: "", imageUrl: "" };

  const downloadFile = (url: string, fileName: string) => {
    const link = document.createElement('a');
    link.href = url;
    link.setAttribute('download', fileName);
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  };

  const renderFullSizeFile = () => {
    if (!selectedFile) return null;

    const fileObject = {
      url: selectedFile.url,
      fileKey: selectedFile.fileKey || selectedFile.url,
      fileName: selectedFile.fileName || 'attachment',
      fileType: selectedFile.fileType,
    };

    if (isImageFile(selectedFile.fileName || '')) {
      return (
        <div className="flex flex-col items-center">
          <Image
            src={selectedFile.url}
            alt="Enlarged Image"
            width={800}
            height={800}
            className="max-h-[70vh] w-auto object-contain"
            priority
          />
          <Button
            variant="outline"
            size="sm"
            className="mt-4"
            onClick={() => downloadFile(selectedFile.url, selectedFile.fileName || 'image')}
          >
            <Download size={14} className="mr-2" />
            Download
          </Button>
        </div>
      );
    }

    return (
      <div className="flex flex-col items-center">
        <FilePreview
          file={fileObject}
          previewSize="large"
          allowDownload={true}
          allowPreview={false}
        />
      </div>
    );
  };

  const messageContainerClassName = `flex flex-col ${
    isMobile
      ? ' w-full h-[100dvh] overflow-hidden'
      : 'h-[calc(100dvh-65px)] sm:h-[calc(100dvh-65px)] md:h-[calc(100dvh-80px)]'
  } bg-background w-full ${
    isMobile ? 'transform transition-transform duration-300 ease-in-out' : ''
  } ${isMobile && isExiting ? 'translate-x-full' : 'translate-x-0'}`;

  return (
    <div className={messageContainerClassName}>
      <div className="">
        <ConversationHeader
          selectedConversation={selectedConversation}
          participantInfo={participantInfo}
          onBack={onBack}
          isMobile={isMobile}
          handleBackClick={handleBackClick}
        />
      </div>

      <div className="flex-1 w-full max-h-[55%] overflow-x-hidden">
        <ScrollArea ref={scrollAreaRef} className="h-full w-[101%] md:w-[100.7%] overflow-x-visible">
          <div className="py-2 px-4 min-h-full md:pb-2">
            <MessageList
              messages={messages}
              currentUserId={currentUserId}
              selectedConversation={selectedConversation}
              participantInfo={participantInfo}
              isOtherUserTyping={isOtherUserTyping}
              handleFileClick={handleFileClick}
            />
            <div ref={bottomRef} className="h-1" />
          </div>
        </ScrollArea>
      </div>

      <div className={''}>
        <MessageInputArea
          onSendMessage={onSendMessage}
          selectedConversation={selectedConversation}
          onTyping={onTyping}
          handleFileClick={handleFileClick}
        />
      </div>

      <Dialog open={!!selectedFile} onOpenChange={(open) => !open && setSelectedFile(null)}>
        <DialogContent className="max-w-3xl" hideCloseButton={false}>
          {selectedFile && (
            <div className="flex flex-col justify-center items-center">
              <h3 className="text-lg font-medium mb-4">{selectedFile.fileName}</h3>
              {renderFullSizeFile()}
            </div>
          )}
        </DialogContent>
      </Dialog>
    </div>
  );
};

export default MessageArea;
</file>

<file path="components/MessageInputArea.tsx">
import React, { useState, useRef, useEffect } from 'react';
import { UploadButton } from "@/app/utils/uploadthing";
import { PaperclipIcon, X } from 'lucide-react';
import Image from "next/image";
import { FilePreview } from '@/components/ui/file-preview';
import { isImageFile } from '@/lib/utils';
import { useWindowSize } from '@/hooks/useWindowSize';
import { useIsMobile } from '@/hooks/use-mobile';

// Import the new AttachmentCarouselDialog
import { AttachmentCarouselDialog, AttachmentFileItem } from '@/components/ui/attachment-carousel-dialog';

interface MessageFile {
  url: string;
  fileName?: string;
  fileKey?: string;
  fileType?: string;
  fileSize?: number;
}

interface UploadData {
  name: string;
  size: number;
  key: string;
  serverData: {
    uploadedBy: string;
    url: string;
  };
  url: string;
  customId: string | null;
  type: string;
}

interface MessageInputAreaProps {
  onSendMessage: (message: string, attachments?: MessageFile[]) => void;
  selectedConversation: any;
  onTyping?: (isTyping: boolean) => void;
  handleFileClick: (file: MessageFile) => void;
}

const getStorageKey = (conversationId: string) => `message_draft_${conversationId}`;
const getRecentConversationKey = () => 'recent_conversation_change';

interface StoredDraft {
  message: string;
  attachments: MessageFile[];
  timestamp: number;
}

interface RecentConversationChange {
  previousId: string;
  message: string;
  attachments: MessageFile[];
  timestamp: number;
}

const MessageInputArea: React.FC<MessageInputAreaProps> = ({
  onSendMessage,
  selectedConversation,
  onTyping,
  handleFileClick,
}) => {
  // Style variables
  const inputAreaClassNames = "flex-1 px-5 py-3 focus:outline-none text-black resize-none w-full min-h-[44px] max-h-[132px] overflow-y-hidden leading-relaxed font-jakarta";
  const inputContainerClassNames = "flex items-center mb-4 bg-white border-gray-300 border focus:outline-none w-full focus:ring-1 focus:ring-black overflow-hidden transition-all duration-300 ease-in-out";

  // Calculate dynamic border radius based on message length and screen width
  const calculateBorderRadius = (messageLength: number, screenWidth: number | undefined) => {
    if (messageLength === 0) return '9999px';

    if (messageLength > 60) {
      return screenWidth && screenWidth >= 768 ? '1.25rem' : '0.375rem';
    } else if (messageLength > 40) {
      return screenWidth && screenWidth >= 768 ? '1.5rem' : '0.5rem';
    } else if (messageLength > 20) {
      return screenWidth && screenWidth >= 768 ? '2rem' : '0.75rem';
    } else {
      return screenWidth && screenWidth >= 768 ? '3rem' : '1.5rem';
    }
  };

  const [newMessageInput, setNewMessageInput] = useState('');
  const [messageAttachments, setMessageAttachments] = useState<MessageFile[]>([]);
  const textareaRef = useRef<HTMLTextAreaElement>(null);
  const inputContainerRef = useRef<HTMLDivElement>(null);
  const typingTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const { width } = useWindowSize();
  const isMobile = useIsMobile();

  const prevConversationIdRef = useRef<string | null>(null);
  // Track if keyboard is visible
  const [isKeyboardVisible, setIsKeyboardVisible] = useState(false);

  // State for controlling the Attachment Carousel Dialog
  const [isAttachmentCarouselOpen, setIsAttachmentCarouselOpen] = useState(false);
  const [carouselInitialIndex, setCarouselInitialIndex] = useState(0);


  // Track if upload button is being interacted with
  const [isUploadActive, setIsUploadActive] = useState(false);

  // Add keyboard detection with window resize event trigger
  useEffect(() => {
    if (!isMobile) return; // Only apply on mobile devices
    
    const triggerResize = () => {
      // Dispatch a resize event to ensure layout recalculations
      window.dispatchEvent(new Event('resize'));
      console.log(`Window resize triggered due to keyboard ${isKeyboardVisible ? 'appearing' : 'disappearing'}`);
    };
    
    const handleFocus = () => {
      // Only trigger if keyboard wasn't already visible
      if (!isKeyboardVisible) {
        setIsKeyboardVisible(true);
        // Small delay to ensure keyboard is fully shown
        setTimeout(triggerResize, 300);
      }
    };

    const handleBlur = () => {
      if (isKeyboardVisible) {
        setIsKeyboardVisible(false);
        // Small delay to ensure keyboard is fully hidden
        setTimeout(triggerResize, 300);
      }
    };

    // Add event listeners to textarea
    if (textareaRef.current) {
      textareaRef.current.addEventListener('focus', handleFocus);
      textareaRef.current.addEventListener('blur', handleBlur);
    }

    // Cleanup event listeners on unmount
    return () => {
      if (textareaRef.current) {
        textareaRef.current.removeEventListener('focus', handleFocus);
        textareaRef.current.removeEventListener('blur', handleBlur);
      }
    };
  }, [isMobile, isKeyboardVisible]);

  useEffect(() => {
    if (selectedConversation?.id !== prevConversationIdRef.current && prevConversationIdRef.current !== null) {
      setNewMessageInput('');
      setMessageAttachments([]);

      if (textareaRef.current) {
        textareaRef.current.style.height = "44px";
      }
    }
    prevConversationIdRef.current = selectedConversation?.id || null;
  }, [selectedConversation]);

  const handleSend = () => {
    const hasContent = newMessageInput.trim() || messageAttachments.length > 0;
    if (!hasContent) return;

    const messageContent = newMessageInput.trim();

    if (messageAttachments.length > 0) {
      onSendMessage(messageContent, messageAttachments);
    } else {
      onSendMessage(messageContent);
    }

    setNewMessageInput('');
    setMessageAttachments([]);
    
    if (textareaRef.current) {
      textareaRef.current.style.height = "44px";
    }
    
    if (selectedConversation?.id) {
      localStorage.removeItem(getStorageKey(selectedConversation.id));
      
      const recentChangeData = localStorage.getItem(getRecentConversationKey());
      if (recentChangeData) {
        const recentChange: RecentConversationChange = JSON.parse(recentChangeData);
        if (recentChange.previousId === selectedConversation.id) {
          localStorage.removeItem(getRecentConversationKey());
        }
      }
    }
  };

  const handleKeyPress = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleSend();
    }
  };

  const handleUploadFinish = (res: UploadData[]) => {
    console.log('=== UPLOAD FINISH ===', res);
    const attachments: MessageFile[] = res.map(r => ({
      url: r.url,
      fileName: r.name,
      fileKey: r.key,
      fileType: r.type,
      fileSize: r.size
    }));
    console.log('Setting message attachments:', attachments);
    setMessageAttachments(prev => [...prev, ...attachments]);
  };

  // Function to open the attachment carousel
  const openAttachmentCarousel = (index: number) => {
    setCarouselInitialIndex(index);
    setIsAttachmentCarouselOpen(true);
  };

  return (
    <div
      className={`${isMobile ? 'z-30 bg-background pr-4 transition-all duration-300' : 'relative pr-0 pb-1 md:pl-4 bg-transparent'} overflow-x-hidden`}
      style={{
        paddingBottom: isMobile ? '8px' : undefined,
      }}
    >
      {messageAttachments.length > 0 && (
        <div className="scrollbar-hide py-1 space-x-2 mb-2 bg-black/15 px-2 rounded">
          {messageAttachments.map((attachment, index) => {
            const handleRemoveAttachment = () => {
              setMessageAttachments(prev => prev.filter((_, i) => i !== index));
            };

            const isImage = isImageFile(attachment.fileName || '');
            const fileObjectForPreview = {
              fileUrl: attachment.url,
              fileKey: attachment.fileKey || attachment.url,
              fileName: attachment.fileName || 'attachment',
              fileType: attachment.fileType,
              fileSize: attachment.fileSize,
            };

            return (
              <div key={index} className="inline-block flex-shrink-0 aspect-square rounded group">
                {isImage ? (
                  <div className="relative aspect-square h-[80px] w-[80px] md:h-[100px] md:w-[100px]">
                    <button
                      className="absolute top-0 right-0 z-10 w-5 h-5 bg-white/80 hover:bg-white/90 rounded-full flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity"
                      onClick={handleRemoveAttachment}
                      aria-label="Remove attachment"
                    >
                      <X size={12} />
                    </button>
                    <Image
                      src={attachment.url}
                      alt={attachment.fileName || "Message Attachment"}
                      width={100}
                      height={100}
                      className="cursor-pointer object-cover aspect-square w-full h-full"
                      onClick={() => openAttachmentCarousel(index)}
                    />
                  </div>
                ) : (
                  <div className="aspect-square h-[80px] w-[80px] md:h-[100px] md:w-[100px]">
                    <FilePreview
                      file={fileObjectForPreview}
                      previewSize="small"
                      allowPreview={false}
                      allowDownload={false}
                      showRemove={true}
                      onRemove={handleRemoveAttachment}
                      onClick={() => openAttachmentCarousel(index)}
                      className="h-full w-full aspect-square"
                    />
                  </div>
                )}
              </div>
            );
          })}
        </div>
      )}

      <div
        ref={inputContainerRef}
        className={`${inputContainerClassNames} ${isMobile ? 'mx-2' : ''}`}
        style={{
          borderRadius: calculateBorderRadius(newMessageInput.length, width)
        }}
      >
        <textarea
          ref={textareaRef}
          className={inputAreaClassNames}
          placeholder="Type a message..."
          value={newMessageInput}
          onChange={(e) => {
            setNewMessageInput(e.target.value);
            const textarea = e.target;
            textarea.style.height = "44px";
            const scrollHeight = textarea.scrollHeight;
            if (scrollHeight > 44) {
              const newHeight = Math.min(scrollHeight, 132);
              textarea.style.height = `${newHeight}px`;
            }
            if (onTyping && selectedConversation) {
              if (typingTimeoutRef.current) {
                clearTimeout(typingTimeoutRef.current);
              }
              onTyping(true);
              typingTimeoutRef.current = setTimeout(() => {
                if (onTyping) {
                  onTyping(false);
                }
              }, 3000);
            }
          }}
          onKeyPress={handleKeyPress}
          disabled={!selectedConversation}
          rows={1}
        />

        <div className="flex items-center px-2">
          <div 
            className={`p-2 ${!selectedConversation ? "opacity-50 pointer-events-none" : ""}`}
            onTouchStart={() => setIsUploadActive(true)}
            onTouchEnd={() => setTimeout(() => setIsUploadActive(false), 500)}
            onMouseDown={() => setIsUploadActive(true)}
            onMouseUp={() => setTimeout(() => setIsUploadActive(false), 500)}
          >
            <UploadButton
              endpoint="messageUploader"
              onClientUploadComplete={(res) => {
                handleUploadFinish(res);
                setIsUploadActive(false);
              }}
              onUploadError={(error) => {
                alert(error.message);
                setIsUploadActive(false);
              }}
              className="p-0"
              content={{
                button: ({ ready, isUploading }) => (
                  <div className="relative">
                    {!isUploading && <PaperclipIcon className="w-5 h-5 text-gray-600" />}
                    {isUploading && (
                      <div className="w-5 h-5 border-2 border-gray-300 border-t-gray-600 rounded-full animate-spin"></div>
                    )}
                  </div>
                ),
                allowedContent: 'Image upload'
              }}
              appearance={{
                button: 'bg-parent focus-within:ring-black w-8 data-[state="uploading"]:after:hidden',
                allowedContent: 'hidden'
              }}
            />
          </div>

          <button
            className="p-2 mx-1 text-gray-600 hover:text-gray-800 disabled:opacity-50"
            onClick={handleSend}
            disabled={!selectedConversation || (!newMessageInput.trim() && messageAttachments.length === 0)}
          >
            <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
              <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-8.707l-3-3a1 1 0 00-1.414 1.414L10.586 9H7a1 1 0 100 2h3.586l-1.293 1.293a1 1 0 101.414 1.414l3-3a1 1 0 000-1.414z" clipRule="evenodd" />
            </svg>
          </button>
        </div>
      </div>

      {/* Use the new AttachmentCarouselDialog component */}
      {messageAttachments.length > 0 && (
        <AttachmentCarouselDialog
          attachments={messageAttachments as AttachmentFileItem[]}
          isOpen={isAttachmentCarouselOpen}
          onOpenChange={setIsAttachmentCarouselOpen}
          initialIndex={carouselInitialIndex}
        />
      )}
    </div>
  );
};

export default MessageInputArea;
</file>

<file path="components/MessageList.tsx">
import React, { useState } from 'react';
import { File, Download } from 'lucide-react';
import Image from "next/image";
import { isImageFile } from '@/lib/utils';
import { FilePreview } from '@/components/ui/file-preview';
import { AttachmentCarouselDialog } from '@/components/ui/attachment-carousel-dialog';

interface MessageFile {
  url: string;
  fileName?: string;
  fileKey?: string;
  fileType?: string;
  fileSize?: number;
}

interface MessageListProps {
  messages: any[];
  currentUserId: string | undefined;
  selectedConversation: any;
  participantInfo: { displayName: string; imageUrl: string };
  isOtherUserTyping?: boolean;
  handleFileClick: (file: MessageFile) => void;
}

const MessageList: React.FC<MessageListProps> = ({
  messages,
  currentUserId,
  selectedConversation,
  participantInfo,
  isOtherUserTyping = false,
  handleFileClick
}) => {
  const [isCarouselOpen, setIsCarouselOpen] = useState(false);
  const [carouselAttachments, setCarouselAttachments] = useState<MessageFile[]>([]);
  const [initialCarouselIndex, setInitialCarouselIndex] = useState(0);
  
  const openAttachmentCarousel = (attachments: MessageFile[], index: number) => {
    setCarouselAttachments(attachments);
    setInitialCarouselIndex(index);
    setIsCarouselOpen(true);
  };
  const renderFileAttachment = (url: string, fileName: string = 'attachment', fileKey?: string, fileType?: string, isGridItem?: boolean) => {
    const fileObject = {
      url,
      fileName,
      fileKey,
      fileType
    };

    if (isImageFile(fileName)) {
      if (isGridItem) {
        return (
          <Image
            src={url}
            alt="Message Attachment"
            layout="fill"
            objectFit="cover"
            className="cursor-pointer"
            onClick={() => handleFileClick(fileObject)}
          />
        );
      } else {
        return (
          <Image
            src={url}
            alt="Message Attachment"
            width={250}
            height={250}
            className="rounded cursor-pointer"
            onClick={() => handleFileClick(fileObject)}
          />
        );
      }
    }

    // For non-image files:
    if (isGridItem) {
      // Custom compact rendering for non-image files in a grid
      return (
        <div
          className="flex h-full flex-col items-center border justify-center pl-2 rounded cursor-pointer"
          onClick={() => handleFileClick(fileObject)}
          title={fileName} // Show full filename on hover
        >
          <File className="" />
          <p className="text-sm truncate w-full text-center mt-2">
            {fileName}
          </p>
          <button
            className="mt-4 flex space-x-2 border p-2 hover:underline items-center"
            onClick={() => downloadFile(fileObject.url, fileObject.fileName || 'image')}
          >
            <Download size={14} className="mr-2" />
            Download
          </button>
        </div>
      );
    } else {
      // Default rendering for non-image files not in a grid
      return (
        <FilePreview
          file={{
            url,
            fileKey: fileKey || url,
            fileName,
            fileType
          }}
          previewSize="small"
          allowPreview={false}
          onClick={() => handleFileClick(fileObject)}
        />
      );
    }
  };

  const downloadFile = (url: string, fileName: string) => {
    const link = document.createElement('a');
    link.href = url;
    link.setAttribute('download', fileName);
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  };

  if (!selectedConversation) {
    return (
      <div className="flex flex-col items-center justify-center h-full">
        <div className="bg-gray-50 rounded-lg p-6 shadow-sm text-center max-w-md">
          <p className="text-gray-500 text-sm">Select a conversation from the list to get started</p>
        </div>
      </div>
    );
  }

  if (!messages || messages.length === 0) {
    return (
      <div className="flex flex-col items-center justify-center h-full">
        <div className="bg-gray-50 rounded-lg p-6 shadow-sm text-center max-w-md">
          <p className="text-gray-700 mb-3">No messages yet.</p>
          <p className="text-gray-500 text-sm">Send a message to start the conversation!</p>
        </div>
      </div>
    );
  }

  // Group consecutive messages by sender and content type
  const messageGroups: any[][] = [];
  let currentGroup: any[] = [];

  // Helper function to determine message type
  const getMessageType = (message: any): string => {
    const hasTextContent = message.content && message.content.trim().length > 0;
    // Check if message has attachments
    if (message.attachments && message.attachments.length > 0) {
      // If there's text content with attachments, treat as a captioned attachment
      if (hasTextContent) return 'captioned_attachment';
      
      // Check if all attachments are images
      const allAttachmentsAreImages = message.attachments.every((attachment: MessageFile) => 
        attachment.fileName ? isImageFile(attachment.fileName) : false
      );
      
      if (allAttachmentsAreImages) return 'image';
      return 'file';
    }
    
    // Text-only message
    return 'text';
  };

  messages.forEach((message, index) => {
    // Get message type for current message
    const currentMessageType = getMessageType(message);
    
    // Start a new group if:
    // 1. It's the first message.
    // 2. The sender is different from the previous message.
    // 3. The current message type is different from the previous message type.
    // 4. The current message is a captioned attachment (always gets its own group).
    const startNewGroup = index === 0 ||
                          message.senderId !== messages[index - 1].senderId ||
                          currentMessageType !== getMessageType(messages[index - 1]) ||
                          currentMessageType === 'captioned_attachment';

    if (startNewGroup) {
      // Start of a new group
      if (currentGroup.length > 0) {
        messageGroups.push(currentGroup);
      }
      currentGroup = [message];
    } else {
      // Continue the current group
      currentGroup.push(message);
    }
  });

  // Push the last group
  if (currentGroup.length > 0) {
    messageGroups.push(currentGroup);
  }

  const renderGroupStatus = (group: any[], isCurrentUserGroup: boolean) => {
    const lastMessage = group[group.length - 1];

    // If the message is still pending (sending)
    if (lastMessage.pending) {
      return <span className="text-xs text-gray-400">Sending...</span>;
    } 
    // If the message failed to send
    if (lastMessage.failed) {
      return <span className="text-xs text-red-500">Failed to send</span>;
    }

    // Check status only for the current user's messages
    if (isCurrentUserGroup) {
      // If the last message in the group has been read
      if (lastMessage.isRead && lastMessage.updatedAt) {
        const date = new Date(lastMessage.updatedAt);
        const now = new Date();
        const diff = now.getTime() - date.getTime();
        const hours = diff / (1000 * 60 * 60);
        let formattedTime: string;

        if (hours < 24) {
          // If less than 24 hours ago, show time
          formattedTime = date.toLocaleTimeString('en-US', {
            hour: 'numeric',
            minute: '2-digit',
            hour12: true
          });
        } else {
          // If more than 24 hours ago, show date
          formattedTime = date.toLocaleDateString('en-US', {
            month: 'short',
            day: 'numeric'
          });
        }
        return <span className="text-xs text-gray-400">{`Read ${formattedTime}`}</span>;
      }

      // If the last message has a delivery status from the server
      if (lastMessage.deliveryStatus === 'delivered') {
        const deliveredTime = lastMessage.deliveredAt ?
          new Date(lastMessage.deliveredAt).toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' }) : '';
        return <span className="text-xs text-gray-400">{deliveredTime ? `Delivered ${deliveredTime}` : "Delivered"}</span>;
      }

      // Default status for sent messages (last one in the group)
      return <span className="text-xs text-gray-400">Sent</span>;
    }

    return null; // No status for the other user's messages
  };

  return (
    <div className='w-full'>
      <AttachmentCarouselDialog 
        attachments={carouselAttachments}
        isOpen={isCarouselOpen}
        onOpenChange={setIsCarouselOpen}
        initialIndex={initialCarouselIndex}
        withDownloadButton={true}
      />
      {messageGroups.map((group, groupIndex) => {
        const firstMessage = group[0];
        const isCurrentUserGroup = firstMessage.senderId === currentUserId;
        const justifyClass = isCurrentUserGroup ? 'justify-end' : 'justify-start';
        const showAvatar = !isCurrentUserGroup; // Show avatar only for the other user's group
        
        const bubbleStyles = isCurrentUserGroup
          ? 'bg-gray-700 text-white border-white/10 pl-5 pr-5 font-normal rounded-br-none'
          : 'bg-gray-100 text-black pr-5 pl-5 rounded-bl-none text-wrap font-normal border-gray-200';

        return (
          <div key={`group-${groupIndex}`} className="mb-3 pr-1 md:pr-0">
            <div className={`flex ${justifyClass}`}>
              {showAvatar && (
                <div className="relative self-end">
                  <img
                    src={participantInfo.imageUrl}
                    alt="Profile"
                    className="w-9 h-9 rounded-full object-cover mr-2"
                  />
                </div>
              )}
              <div className={`max-w-[70%] text-black rounded-2xl border leading-snug shadow-md py-2 overflow-hidden overflow-wrap-anywhere ${bubbleStyles}`}>
                {(() => {
                  // Get regular text messages (with no attachments)
                  const textMessages = group.filter(msg => 
                    getMessageType(msg) === 'text'
                  );

                  // Get captioned attachment messages
                  const captionedAttachmentMessages = group.filter(msg => 
                    getMessageType(msg) === 'captioned_attachment'
                  );

                  // Get messages with image attachments only (no caption)
                  const imageOnlyMessages = group.filter(msg => 
                    getMessageType(msg) === 'image'
                  );

                  // Get messages with file attachments only (no caption)
                  const fileOnlyMessages = group.filter(msg => 
                    getMessageType(msg) === 'file'
                  );

                  // Then collect all image attachments across all image-only messages in this group
                  const allImageAttachments: {attachment: MessageFile, messageId: string | number}[] = [];
                  imageOnlyMessages.forEach(msg => {
                    if (msg.attachments && msg.attachments.length > 0) {
                      const imageAttachments = msg.attachments.filter((att: MessageFile) => 
                        att.fileName ? isImageFile(att.fileName) : false
                      );
                      imageAttachments.forEach((att: MessageFile) => {
                        allImageAttachments.push({
                          attachment: att,
                          messageId: msg.id || `msg-${group.indexOf(msg)}`
                        });
                      });
                    }
                  });

                  return (
                    <>
                      {/* Render text messages */}
                      {textMessages.map((message, messageIndex) => (
                        <div 
                          key={message.id || `text-msg-${messageIndex}`}
                          className={`${messageIndex > 0 ? 'pt-1.5 border-gray-500/30' : ''} px-0 py-0`}
                        >
                          <p className="whitespace-pre-wrap break-words px-0 py-0 overflow-hidden overflow-wrap-anywhere">
                            {message.content}
                          </p>
                        </div>
                      ))}

                      {/* Render image grid */}
                      {allImageAttachments.length > 0 && (
                        <div className={`${textMessages.length > 0 ? 'mt-2' : 'mt-0'}`}>
                          <div className="flex flex-wrap gap-1">
                            {allImageAttachments.map((item, index) => {
                              const imageSize = allImageAttachments.length === 1 ? '250px' : '120px';
                              return (
                                <div
                                  key={`${item.messageId}-img-${index}`}
                                  className="relative overflow-hidden rounded cursor-pointer"
                                  style={{
                                    width: imageSize,
                                    height: imageSize,
                                  }}
                                  onClick={() => openAttachmentCarousel(
                                    allImageAttachments.map(i => i.attachment),
                                    index
                                  )}
                                >
                                  <Image
                                    src={item.attachment.url}
                                    alt="Message Attachment"
                                    layout="fill"
                                    objectFit="cover"
                                  />
                                </div>
                              );
                            })}
                          </div>
                        </div>
                      )}

                      {/* Render file attachments */}
                      {fileOnlyMessages.map((message, messageIndex) => {
                        const nonImageAttachments = message.attachments.filter((att: MessageFile) => 
                          att.fileName ? !isImageFile(att.fileName) : true
                        );
                        
                        return (
                          <div 
                            key={message.id || `file-msg-${messageIndex}`}
                            className={`${(textMessages.length > 0 || allImageAttachments.length > 0 || messageIndex > 0) ? 'mt-2' : 'mt-0'}`}
                          >
                            {nonImageAttachments.map((attachment: MessageFile, attIndex: number) => (
                              <div key={`${message.id}-file-${attIndex}`} className="max-w-xs mx-auto mb-2">
                                {renderFileAttachment(attachment.url, attachment.fileName, attachment.fileKey, attachment.fileType, false)}
                              </div>
                            ))}
                          </div>
                        );
                      })}

                      {/* Render captioned attachment messages */}
                      {captionedAttachmentMessages.map((message, messageIndex) => {
                        const isImagesOnly = message.attachments.every((att: MessageFile) => 
                          att.fileName ? isImageFile(att.fileName) : false
                        );
                        
                        return (
                          <div 
                            key={message.id || `captioned-msg-${messageIndex}`}
                            className={`${messageIndex > 0 || textMessages.length > 0 || allImageAttachments.length > 0 || fileOnlyMessages.length > 0 ? 'mt-3' : 'mt-0'}`}
                          >
                            {/* Render attachments first */}
                            {isImagesOnly ? (
                              <div className="mb-2">
                                <div className="flex flex-wrap gap-1">
                                  {message.attachments.map((attachment: MessageFile, attIndex: number) => {
                                    const imageSize = message.attachments.length === 1 ? '250px' : '120px';
                                    return (
                                      <div
                                        key={`${message.id}-captioned-img-${attIndex}`}
                                        className="relative overflow-hidden rounded cursor-pointer"
                                        style={{
                                          width: imageSize,
                                          height: imageSize,
                                        }}
                                        onClick={() => openAttachmentCarousel(message.attachments, attIndex)}
                                      >
                                        <Image
                                          src={attachment.url}
                                          alt="Message Attachment"
                                          layout="fill"
                                          objectFit="cover"
                                        />
                                      </div>
                                    );
                                  })}
                                </div>
                              </div>
                            ) : (
                              <div className="mb-2">
                                {message.attachments.map((attachment: MessageFile, attIndex: number) => (
                                  <div key={`${message.id}-file-${attIndex}`} className="max-w-xs mx-auto mb-2">
                                    {renderFileAttachment(attachment.url, attachment.fileName, attachment.fileKey, attachment.fileType, false)}
                                  </div>
                                ))}
                              </div>
                            )}
                            
                            {/* Render caption text */}
                            <p className="whitespace-pre-wrap break-words px-0 py-0 overflow-hidden overflow-wrap-anywhere">
                              {message.content}
                            </p>
                          </div>
                        );
                      })}
                    </>
                  );
                })()}
              </div>
            </div>

            {isCurrentUserGroup && renderGroupStatus(group, isCurrentUserGroup) && (
              <div className={`flex ${justifyClass} mt-1`}>
                <div className="text-right mr-1">
                  {renderGroupStatus(group, isCurrentUserGroup)}
                </div>
              </div>
            )}
          </div>
        );
      })}
      
      {isOtherUserTyping && (
        <div className="flex justify-start mb-4 mt-4">
          <div className="relative">
            <img
              src={participantInfo.imageUrl}
              alt="Profile"
              className="w-9 h-9 rounded-full mr-3 absolute bottom-[-12px]"
            />
            <div className="w-8 mr-3" />
          </div>
          <div className="max-w-[70%] bg-gray-100 shadow-md pl-5 pr-5 rounded-[15px] rounded-bl-none pt-3 pb-2 border border-gray-200">
            <div className="flex space-x-1 items-center h-5 mb-[2px]">
              <div className="w-2 h-2 bg-gray-400 rounded-full animate-bounce" style={{ animationDelay: '0ms' }}></div>
              <div className="w-2 h-2 bg-gray-400 rounded-full animate-bounce" style={{ animationDelay: '150ms' }}></div>
              <div className="w-2 h-2 bg-gray-400 rounded-full animate-bounce" style={{ animationDelay: '300ms' }}></div>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

export default MessageList;
</file>

<file path="message-area-refactor.md">
# Refactoring Checklist for MessageArea.tsx (TDD Approach)

The main goal is to break down the large `MessageArea.tsx` component into smaller, more manageable, and testable sub-components. This will improve readability, maintainability, and allow for isolated testing of each part.

## 1. Setup & Analysis:
- [ ] Ensure your testing environment (e.g., Vitest, jsdom, React Testing Library) is correctly configured for testing React components and hooks.
- [ ] Thoroughly analyze `MessageArea.tsx`:
    - Identify its core responsibilities (e.g., displaying a list of messages, handling message input, managing file attachments, WebSocket interactions via hooks).
    - Pinpoint distinct UI sections and logic blocks that can be extracted into separate components or custom hooks.

## 2. Iterative Component Extraction (Repeat for each new component):

### `MessageList` Component (Displays the list of messages):
- [ ] **Define API:** Determine props (e.g., `messages: WebSocketMessageData[]`, `currentUser: User`, `onRetrySendMessage: (messageId: string) => void`).
- [ ] **Write Tests (TDD):**
    - [ ] Renders correctly with a list of messages.
    - [ ] Renders an empty state/placeholder when there are no messages.
    - [ ] Correctly passes necessary props to child `MessageItem` components.
    - [ ] Handles scrolling behavior (e.g., auto-scroll to bottom for new messages).
- [ ] **Implement:** Create `MessageList.tsx` and implement the component to make tests pass.
- [ ] **Integrate:** Replace the message listing logic in `MessageArea.tsx` with the new `<MessageList />` component.

### `MessageItem` Component (Displays an individual message):
- [ ] **Define API:** Determine props (e.g., `message: WebSocketMessageData`, `isCurrentUser: boolean`, `onDownloadAttachment: (url: string, fileName: string) => void`, `onRetry: () => void`).
- [ ] **Write Tests (TDD):**
    - [ ] Renders message content (text, timestamp, sender).
    - [ ] Differentiates styling for messages from the current user vs. other users.
    - [ ] Displays file attachments (if any) with download links/buttons.
    - [ ] Calls `onDownloadAttachment` when an attachment download is triggered.
    - [ ] Shows status indicators (e.g., sending, sent, failed) and retry options for failed messages.
- [ ] **Implement:** Create `MessageItem.tsx` and implement the component to make tests pass.
- [ ] **Integrate:** Use `<MessageItem />` within the `MessageList` component.

### `MessageInputArea` Component (Handles text input, send button, attachments):
- [ ] **Define API:** Determine props (e.g., `onSendMessage: (text: string, attachments: File[]) => void`, `onSendTyping: () => void`, `disabled: boolean`).
- [ ] **Write Tests (TDD):**
    - [ ] Renders text input, send button, and attachment button.
    - [ ] Calls `onSendMessage` with text and attachments when the send button is clicked or Enter is pressed.
    - [ ] Calls `onSendTyping` when the input value changes.
    - [ ] Handles file selection via the attachment button.
    - [ ] Displays previews for selected attachments (consider an `AttachmentPreview` sub-component if complex).
    - [ ] Clears input and attachment previews after a message is sent.
    - [ ] Disables input/buttons when `disabled` prop is true.
- [ ] **Implement:** Create `MessageInputArea.tsx` and implement the component to make tests pass.
- [ ] **Integrate:** Replace the input logic in `MessageArea.tsx` with the new `<MessageInputArea />` component.

### (Optional) `AttachmentPreviewItem` Component (Displays a single selected attachment before sending):
- [ ] **Define API:** Props like `file: File`, `onRemove: (file: File) => void`.
- [ ] **Write Tests (TDD):**
    - [ ] Renders file name, size, and a remove button.
    - [ ] Calls `onRemove` when the remove button is clicked.
- [ ] **Implement:** Create `AttachmentPreviewItem.tsx`.
- [ ] **Integrate:** Use within `MessageInputArea.tsx`.

## 3. Hook Refinement (If necessary):
- [ ] Review `useWebSocketManager` and any other custom hooks directly used or heavily influencing `MessageArea.tsx`.
- [ ] **Write Tests (TDD) for Hooks:** Ensure hooks are testable in isolation (e.g., using `@testing-library/react-hooks`).
    - Test state transitions, function calls, and effects.
- [ ] **Refactor Hooks:**
    - Ensure hooks have a single, clear responsibility.
    - Break down overly complex hooks if possible.
    - Optimize dependencies to prevent unnecessary re-renders or re-executions.

## 4. Update `MessageArea.tsx` (The Orchestrator):
- [ ] `MessageArea.tsx` will now primarily orchestrate the new sub-components.
- [ ] Manage state that needs to be shared between the new components (lift state up if necessary).
- [ ] Pass down props and callbacks to the sub-components.
- [ ] **Write/Update Integration Tests for `MessageArea.tsx`:**
    - Test the interaction between the sub-components.
    - Ensure data flows correctly (e.g., sending a message updates the `MessageList`).
    - Verify overall functionality remains intact.

## 5. Styling:
- [ ] Ensure styles are correctly migrated or applied to the new components.
- [ ] Maintain consistency in styling (e.g., using CSS Modules, Tailwind CSS, styled-components). Co-locate styles with their components where appropriate.

## 6. Final Review and Cleanup:
- [ ] Remove any dead code from the original `MessageArea.tsx` and any new files.
- [ ] Ensure consistent code formatting and adherence to project linting rules.
- [ ] Perform a final manual test of all messaging functionalities.
- [ ] Review for any performance regressions or opportunities for optimization.
</file>

<file path="message-interface.tsx">
'use client';
import React, { useState, useEffect, useRef, useCallback } from 'react';
import { useSearchParams } from 'next/navigation'; // Import useSearchParams
import { v4 as uuidv4 } from 'uuid'; // Import uuid
import ConversationList from './components/ConversationList';
import MessageArea from './components/MessageArea';
import {
  getAllConversations,
  createConversation,
  deleteConversation,
  createMessage,
} from '@/app/actions/conversations';
import { markMessagesAsReadByTimestamp } from '@/app/actions/messages';
import { time } from 'console';
// Import the hook and its MessageData type
import { useWebSocketManager, MessageData as HookMessageData } from '@/hooks/useWebSocketManager';

interface ExtendedConversation {
  id: string;
  messages: any[]; // Consider using a more specific type, perhaps related to HookMessageData
  participants: {
    userId: string;
    role: string;
    User: { id: string; firstName?: string | null; email?: string | null; imageUrl?: string | null };
  }[];
  isUnread?: boolean; // Added for augmentedConversations
}

// Use HookMessageData or ensure local MessageData is compatible.
// For this refactoring, we'll assume HookMessageData is the source of truth if different.
// If your local MessageData has fields not in HookMessageData that are still needed locally,
// you might need to merge or extend. For now, let's use the local one if it's more specific
// to the component's immediate needs, assuming compatibility with what's sent/received.
// However, it's generally better to have a single source of truth for such types.
// For this exercise, I'll keep the local MessageData and assume it's what the component internally works with.
// The hook's MessageData is for what it sends/receives.

// Define AttachmentData for clarity, similar to MessageFile in MessageArea
interface AttachmentData {
  url: string; // url from uploadthing
  fileName?: string;
  fileKey?: string;
  fileType?: string;
  fileSize?: number;
}

interface MessageData {
  content: string;
  senderRole: 'Host' | 'Tenant';
  conversationId: string;
  receiverId: string;
  senderId?: string;
  id?: string;
  clientId?: string; // Added clientId for tracking pending messages
  type?: 'message' | 'file' | 'typing' | 'read_receipt'; // Expanded type
  attachments?: AttachmentData[]; // Added for multiple attachments
  isTyping?: boolean;
  timestamp?: string;
  messageIds?: string[];
  confirmedDeliveryAt?: string;
  pending?: boolean;
  failed?: boolean;
  deliveredAt?: string;
  deliveryStatus?: 'sending' | 'sent' | 'delivered' | 'read' | 'failed';
}

/**
 * Custom hook to detect mobile devices
 * Accepts initial mobile state from server-side detection
 */
const useMobileDetect = (initialIsMobile = false) => {
  const [isMobile, setIsMobile] = useState(initialIsMobile);

  const checkMobile = () => setIsMobile(window.innerWidth < 768);

  useEffect(() => {
    // Only do client-side detection after initial render
    checkMobile();
    window.addEventListener('resize', checkMobile);
    return () => window.removeEventListener('resize', checkMobile);
  }, []);

  return isMobile;
};

/**
 * Helper function to determine if a conversation has unread messages for the current user.
 */
const conversationHasUnreadMessages = (conv: ExtendedConversation, userId: string): boolean => {
  if (!conv || !conv.messages || !userId) {
    return false;
  }
  return conv.messages.some(message =>
    message.senderId !== userId && !message.isRead
  );
};

/**
 * Utility function to add a message to a conversation
 */
const addMessageToConversation = (
  allConversations: ExtendedConversation[],
  conversationId: string,
  message: any
) => {
  return allConversations.map((conv) =>
    conv.id === conversationId
      ? { ...conv, messages: [...conv.messages, message] }
      : conv
  );
};

/**
 * Utility function to update a message in a conversation
 */
const updateMessageInConversation = (
  allConversations: ExtendedConversation[],
  conversationId: string,
  messageId: string, // Match by the persistent messageId
  updatedMessage: any
) => {
  return allConversations.map((conv) =>
    conv.id === conversationId
      ? {
        ...conv,
        messages: conv.messages.map((msg) =>
          msg.id === messageId ? { ...msg, ...updatedMessage, pending: false } : msg // Match by id
        ),
      }
      : conv
  );
};

/**
 * Utility function to mark messages as read in a conversation
 */
const markMessagesAsRead = (
  allConversations: ExtendedConversation[],
  conversationId: string,
  userId: string,
  timestamp: string
) => {
  return allConversations.map((conv) =>
    conv.id === conversationId
      ? {
        ...conv,
        messages: conv.messages.map((msg) =>
          msg.senderId !== userId && msg.createdAt && new Date(msg.createdAt) <= new Date(timestamp)
            ? { ...msg, isRead: true }
            : msg
        ),
      }
      : conv
  );
};

/** Utility function to update the read timestamp (updatedAt) for specific messages */
const updateMessagesReadTimestamp = (
  allConversations: ExtendedConversation[],
  conversationId: string,
  messageIds: string[],
  timestamp: string
) => {
  return allConversations.map((conv) =>
    conv.id === conversationId
      ? {
        ...conv,
        isUnread: false,
        messages: conv.messages.map((msg) =>
          msg.id && messageIds.includes(msg.id)
            ? { ...msg, updatedAt: timestamp, deliveryStatus: 'read', isRead: true }
            : msg
        ),
      }
      : conv
  );
};

/**
 * Utility function to filter conversations by role
 */
const filterConversationsByRole = (
  conversations: ExtendedConversation[],
  userId: string,
  role: string
) => {
  return role === 'all'
    ? conversations
    : conversations.filter((conv) =>
      conv.participants.find((p) => p.userId === userId)?.role === role
    );
};

/**
 * Utility function to create an optimistic message
 */
const createOptimisticMessage = (
  content: string,
  attachments: AttachmentData[] | undefined, // Changed from single file to array
  conversationId: string,
  senderId: string,
  messageId: string // Use the generated messageId
) => ({
  id: messageId, // Use the generated messageId directly
  content,
  senderId,
  conversationId,
  createdAt: new Date().toISOString(),
  isRead: false,
  pending: true,
  deliveryStatus: 'sending',
  type: attachments && attachments.length > 0 ? 'file' : 'message',
  attachments: attachments, // Add attachments array
});

/**
 * Utility function to send a message via REST API
 */
const sendMessageViaRest = async (
  messageData: MessageData, // Ensure this MessageData is compatible with createMessage
  createMessageFunc: (data: any) => Promise<any> // Renamed to avoid conflict
) => {
  try {
    return await createMessageFunc(messageData);
  } catch (error) {
    console.error('REST API send failed:', error);
    throw error;
  }
};

/**
 * Utility function to update typing status
 */
const updateTypingStatus = (
  typingUsers: Record<string, { isTyping: boolean; timestamp: string }>,
  conversationId: string,
  senderId: string,
  isTyping: boolean
) => ({
  ...typingUsers,
  [`${conversationId}:${senderId}`]: { isTyping, timestamp: new Date().toISOString() },
});

/**
 * Utility function to clear typing timeout
 */
const clearTypingTimeout = (
  typingTimeouts: Record<string, NodeJS.Timeout>,
  key: string
) => {
  if (typingTimeouts[key]) {
    clearTimeout(typingTimeouts[key]);
    delete typingTimeouts[key];
  }
};

/**
 * Main Message Interface Component
 */
const MessageInterface = ({
  conversations: initialConversations,
  user,
  initialIsMobile = false
}: {
  conversations: ExtendedConversation[],
  user: { id: string, imageUrl?: string | null, publicMetadata?: { role?: string } },
  initialIsMobile?: boolean
}) => {
  const [allConversations, setAllConversations] = useState<ExtendedConversation[]>([]);
  const [selectedConversationId, setSelectedConversationId] = useState<string | null>(null);
  // Always show the conversation list first on mobile
  const [sidebarVisible, setSidebarVisible] = useState(true);
  const [tabs, setTabs] = useState<'all' | 'Host' | 'Tenant'>('all');
  const [unreadHostMessages, setUnreadHostMessages] = useState(0);
  const [unreadTenantMessages, setUnreadTenantMessages] = useState(0);
  const [typingUsers, setTypingUsers] = useState<
    Record<string, { isTyping: boolean; timestamp: string }>
  >({});
  const typingTimeoutRef = useRef<Record<string, NodeJS.Timeout>>({});
  const [isAdmin, setIsAdmin] = useState(false);
  const isMobile = useMobileDetect(initialIsMobile);
  const selectedConversationIdRef = useRef<string | null>(null); // Ref for selected ID
  const searchParams = useSearchParams(); // Get search params

  const socketUrl = process.env.NEXT_PUBLIC_GO_SERVER_URL || 'http://localhost:8080';

  // Callback for handling incoming messages from the WebSocket hook
  const onMessageReceivedHandler = useCallback((message: HookMessageData) => {
    if (!user) return;
    const currentSelectedId = selectedConversationIdRef.current;


    if (message.type !== 'typing') {
      console.log('TYPE', message.type)
      console.log("RECIEVED", message);
    }

    // Logic for message delivery confirmation (echoed back from server)
    if (message.id && message.senderId === user?.id && message.confirmedDeliveryAt) {
      setAllConversations((prev) =>
        updateMessageInConversation(prev, message.conversationId, message.id, {
          pending: false,
          deliveryStatus: message.deliveryStatus || 'delivered',
          deliveredAt: message.deliveredAt || new Date().toISOString()
        })
      );
      // If this confirmed message is in the currently selected conversation,
      // we might want to trigger a read receipt for it if the window is active.
      // This part is complex and depends on focus state, usually handled by handleSelectConversation.
      // For now, just updating its status.
      return;
    }

    // Logic for new incoming messages from other users
    if (message.senderId !== user.id && (message.type === 'message' || message.type === 'file')) {
      setAllConversations((prevConversations) => {
        const isActiveConversation = message.conversationId === currentSelectedId;
        const activeConvo = isActiveConversation ? prevConversations.find(c => c.id === currentSelectedId) : null;
        const isFromActiveConvoOtherParticipant = activeConvo &&
          message.senderId === activeConvo.participants.find(p => p.userId !== user.id)?.userId;

        let messageToProcess = { ...message } as any; // Cast to any to add local fields like isRead

        if (isFromActiveConvoOtherParticipant) {
          messageToProcess.deliveryStatus = 'read';
          messageToProcess.isRead = true;
          messageToProcess.updatedAt = new Date().toISOString();

          // Send read receipt via hook
          if (webSocketManager.isConnected && messageToProcess.id) {
            webSocketManager.sendReadReceipt({
              conversationId: messageToProcess.conversationId,
              receiverId: messageToProcess.senderId, // This is the original sender of the message
              senderId: user.id,
              timestamp: messageToProcess.updatedAt,
              messageIds: [messageToProcess.id]
            });
          }
        }

        const newState = addMessageToConversation(prevConversations, messageToProcess.conversationId, messageToProcess);

        if (message.senderId !== user.id && !messageToProcess.isRead && !isActiveConversation) {
          const convForRoleCheck = prevConversations.find(c => c.id === message.conversationId);
          if (convForRoleCheck) {
            const userRoleInConv = convForRoleCheck.participants.find(p => p.userId === user.id)?.role;
            if (userRoleInConv === 'Host') setUnreadHostMessages(prev => prev + 1);
            else if (userRoleInConv === 'Tenant') setUnreadTenantMessages(prev => prev + 1);
          }
        }
        return newState;
      });
    }
  }, [user, /* webSocketManager.sendReadReceipt, webSocketManager.isConnected */]); // Dependencies will be updated by ESLint or manually after defining webSocketManager

  // Callback for handling typing indicators from the WebSocket hook
  const onTypingReceivedHandler = useCallback((typingData: HookMessageData) => {
    if (!user || typingData.senderId === user.id) return;
    handleTypingMessage(typingData);
  }, [user]);

  // Callback for handling read receipts from the WebSocket hook
  const onReadReceiptReceivedHandler = useCallback((receiptData: HookMessageData) => {
    if (!user || receiptData.senderId === user.id || !receiptData.messageIds || !receiptData.timestamp) return;
    setAllConversations((prev) =>
      updateMessagesReadTimestamp(prev, receiptData.conversationId, receiptData.messageIds!, receiptData.timestamp!)
    );
  }, [user]);

  const onConnectionStatusChangeHandler = useCallback((status: { isConnected: boolean; circuitOpen: boolean }) => {
    console.log('[MessageInterface] Connection Status Changed:', status);
    // You can update local state here if needed, e.g., for more complex UI based on connection status
    // For now, the hook's returned isConnected and circuitOpen are used directly in JSX
  }, []);

  const webSocketManager = useWebSocketManager({
    socketUrl,
    userId: user?.id || null,
    onMessageReceived: onMessageReceivedHandler,
    onTypingReceived: onTypingReceivedHandler,
    onReadReceiptReceived: onReadReceiptReceivedHandler,
    onConnectionStatusChange: onConnectionStatusChangeHandler,
  });

  // Update onMessageReceivedHandler dependencies now that webSocketManager is defined
  useEffect(() => {
    // This is a common pattern if a callback needs to access methods from the object it's part of.
    // Here, onMessageReceivedHandler might need webSocketManager.sendReadReceipt.
    // To avoid circular dependencies or stale closures, ensure all dependencies are correct.
    // For simplicity, if onMessageReceivedHandler is stable or its dependencies are primitive,
    // this might not be an issue. Let's assume current deps are fine or will be fixed by linter.
  }, [onMessageReceivedHandler]);


  // Initialize conversations and set admin status
  useEffect(() => {
    if (user) {
      setAllConversations(initialConversations);
      setIsAdmin(user.publicMetadata?.role === 'admin');

      const convoIdFromQuery = searchParams.get('convo');
      if (convoIdFromQuery) {
        const conversationExists = initialConversations.some(conv => conv.id === convoIdFromQuery);
        if (conversationExists) {
          setTimeout(() => {
            handleSelectConversation(convoIdFromQuery);
            // The markMessagesAsReadByTimestamp was here, it's also in handleSelectConversation
            // Let's ensure it's consistently handled.
            // markMessagesAsReadByTimestamp(convoIdFromQuery, new Date()); // This is a server action

            // The logic to update client state for read messages is in handleSelectConversation
          }, 0);
        } else {
          console.warn(`Conversation ID "${convoIdFromQuery}" from query param not found in user's conversations.`);
        }
      }
    }
    // The hook manages its own connection lifecycle and cleanup.
    // No need for socketRef.current.disconnect() or clearing timeouts here related to socket.
  }, [user, initialConversations, searchParams]); // handleSelectConversation is memoized or stable

  // We'll keep this effect since it's for the sidebar visibility, not keyboard related
  useEffect(() => {
    if (isMobile) {
      document.body.style.overflow = sidebarVisible ? 'hidden' : 'auto';
      return () => {
        document.body.style.overflow = 'auto';
      };
    }
  }, [isMobile, sidebarVisible]);

  // Note: updateUnreadCounts logic is now integrated into onMessageReceivedHandler


  const handleTypingMessage = (message: any) => { // message type can be HookMessageData
    const key = `${message.conversationId}:${message.senderId}`;
    setTypingUsers((prev) => updateTypingStatus(prev, message.conversationId, message.senderId, message.isTyping));
    if (message.isTyping) {
      clearTypingTimeout(typingTimeoutRef.current, key);
      typingTimeoutRef.current[key] = setTimeout(() => {
        setTypingUsers((prev) => updateTypingStatus(prev, message.conversationId, message.senderId, false));
      }, 5000);
    }
  };

  const sendTypingStatus = (isTyping: boolean) => {
    if (!user || !selectedConversationId) return;

    const conv = allConversations.find((c) => c.id === selectedConversationId);
    if (!conv) return;

    const receiver = conv.participants.find((p) => p.userId !== user.id);
    if (receiver) {
      const message: Partial<HookMessageData> = { // Send data compatible with HookMessageData
        isTyping,
        conversationId: selectedConversationId,
        receiverId: receiver.userId,
        senderId: user.id,
        // senderRole: conv.participants.find((p) => p.userId === user.id)?.role as 'Host' | 'Tenant',
        // content: '', // Not needed for typing event as per hook
        timestamp: new Date().toISOString(), // Hook might generate its own or expect it
      };
      webSocketManager.sendTyping(message);
    }
  };

  const handleSelectConversation = useCallback(async (conversationId: string) => {
    if (!user) return;

    setSelectedConversationId(conversationId);
    selectedConversationIdRef.current = conversationId;

    // On mobile, hide the sidebar when a conversation is selected to show the message area
    if (isMobile) {
      setSidebarVisible(false);
    }

    const conv = allConversations.find((c) => c.id === conversationId);
    if (!conv) return;

    const userRole = conv.participants.find((p) => p.userId === user.id)?.role;
    if (userRole === 'Host') setUnreadHostMessages(0);
    else if (userRole === 'Tenant') setUnreadTenantMessages(0);

    const unreadMessages = conv.messages.filter(m =>
      m.senderId !== user.id && !m.isRead && m.id // Ensure message has an ID
    );

    if (unreadMessages.length > 0) {
      const timestamp = new Date().toISOString();
      const messageIdsToMarkRead = unreadMessages.map(m => m.id).filter(id => !!id);

      setAllConversations((prev) =>
        updateMessagesReadTimestamp(prev, conversationId, messageIdsToMarkRead, timestamp)
      );

      const receiver = conv.participants.find((p) => p.userId !== user.id);
      if (webSocketManager.isConnected && receiver && messageIdsToMarkRead.length > 0) {
        webSocketManager.sendReadReceipt({
          conversationId,
          receiverId: receiver.userId,
          senderId: user.id,
          timestamp: timestamp,
          messageIds: messageIdsToMarkRead
        });
      }
      // Server action to persist read status
      await markMessagesAsReadByTimestamp(conversationId, new Date(timestamp));
    }
  }, [user, allConversations, webSocketManager.isConnected, webSocketManager.sendReadReceipt, isMobile]);


  const handleSendMessage = async (
    content: string,
    attachments?: AttachmentData[] // Changed from single file to array, matching MessageArea.tsx
  ) => {
    if (!user || !selectedConversationId) return;

    const conv = allConversations.find((c) => c.id === selectedConversationId);
    if (!conv) return;

    const receiver = conv.participants.find((p) => p.userId !== user.id);
    if (!receiver) return;

    sendTypingStatus(false); // Call local sendTypingStatus which uses the hook
    const messageId = `message_${uuidv4()}`;

    // Ensure messageData conforms to HookMessageData for sending via hook
    const messageData: HookMessageData = {
      id: messageId,
      content,
      conversationId: selectedConversationId,
      receiverId: receiver.userId,
      senderId: user.id,
      senderRole: conv.participants.find((p) => p.userId === user.id)?.role as 'Host' | 'Tenant',
      timestamp: new Date().toISOString(),
      createdAt: new Date().toISOString(),
      type: attachments && attachments.length > 0 ? 'file' : 'message',
      attachments: attachments, // Pass the array of attachments
      deliveryStatus: 'sending', // Optimistic status
      pending: true,
    };

    const optimisticMessage = createOptimisticMessage(content, attachments, selectedConversationId, user.id, messageId);
    setAllConversations((prev) => addMessageToConversation(prev, selectedConversationId, optimisticMessage));

    try {
      console.log('Sending message via WebSocket hook with acknowledgment');
      // The hook's sendMessage expects HookMessageData
      const ack = await webSocketManager.sendMessage(messageData); // Default timeout from hook
      console.log('Message successfully delivered via WebSocket hook:', ack);

      setAllConversations((prev) =>
        updateMessageInConversation(prev, selectedConversationId, messageId, {
          pending: false,
          deliveryStatus: 'delivered',
          deliveredAt: ack.timestamp || new Date().toISOString(),
          // id: ack.id || messageId, // Server might return its own ID
        })
      );
    } catch (error) {
      console.error('WebSocket hook message delivery failed:', error);
      // Fall back to REST API
      try {
        console.log('Attempting to send message via REST API due to WebSocket failure');
        // Ensure the data sent to createMessage (server action) is what it expects.
        // It might expect a slightly different format than HookMessageData.
        // For now, assume messageData (which is HookMessageData) is compatible enough or createMessage handles it.
        const savedMessage = await sendMessageViaRest(messageData as any, createMessage); // Cast if local MessageData is different
        setAllConversations((prev) =>
          updateMessageInConversation(prev, selectedConversationId, messageId, {
            ...savedMessage,
            pending: false,
            deliveryStatus: 'delivered',
            deliveredAt: new Date().toISOString()
          })
        );
        console.log('Message successfully delivered via REST API after WebSocket failure');
      } catch (restError) {
        console.error('REST API message delivery also failed:', restError);
        setAllConversations((prev) =>
          updateMessageInConversation(prev, selectedConversationId, messageId, {
            failed: true,
            pending: false,
            deliveryStatus: 'failed'
          })
        );
      }
    }
  };

  const handleCreateConversation = async (email: string) => {
    if (!user) return;

    const newConvData = await createConversation(email, 'Host', 'Tenant');
    // Ensure newConvData structure matches ExtendedConversation, especially messages and participants
    const newConv: ExtendedConversation = {
      id: newConvData.id,
      messages: newConvData.messages || [], // Ensure messages is an array
      participants: newConvData.participants || [], // Ensure participants is an array
    };
    setAllConversations((prev) => [...prev, newConv]);
  };

  const handleDeleteAllConversations = async () => {
    if (!confirm('Are you sure you want to delete all conversations?')) return;
    await Promise.all(allConversations.map((c) => deleteConversation(c.id)));
    setAllConversations([]);
    setSelectedConversationId(null);
    selectedConversationIdRef.current = null; // Update ref
  };

  const toggleSidebar = () => setSidebarVisible((prev) => !prev);

  // Early return if user is not available
  if (!user) return null;

  // Filter conversations first by role
  const roleFilteredConversations = filterConversationsByRole(allConversations, user.id, tabs);

  // Augment conversations with isUnread status before passing down
  const augmentedConversations = roleFilteredConversations.map(conv => ({
    ...conv,
    isUnread: conversationHasUnreadMessages(conv, user.id)
  }));

  const selectedConversation = allConversations.find((c) => c.id === selectedConversationId) || null;
  const messages = selectedConversation ? [...selectedConversation.messages] : [];
  const isOtherUserTyping =
    selectedConversationId && selectedConversation && user &&
    typingUsers[`${selectedConversationId}:${selectedConversation.participants.find((p) => p.userId !== user.id)?.userId}`]?.isTyping;

  return (
    <div className="flex flex-col h-full bg-background">
      <div className="flex flex-1 overflow-hidden relative">
        <div
          className={`md:block h-full bg-background ${isMobile ? 'absolute inset-0 transition-transform duration-300 w-full' : 'static w-1/3 min-w-[310px] max-w-[380px]'} ${isMobile && !sidebarVisible ? '-translate-x-full' : 'translate-x-0'}`}
        >
          <ConversationList
            conversations={augmentedConversations} // Pass augmented conversations
            onSelectConversation={handleSelectConversation}
            onCreateConversation={handleCreateConversation}
            user={user}
            onTabChange={setTabs}
            activeTab={tabs}
            selectedConversationId={selectedConversationId}
          />
        </div>
        <div
          className={`bg-background ${
            isMobile
              ? 'fixed top-0 left-0 right-0 bottom-0 z-50 transition-transform duration-300 w-full overflow-y-hidden'
              : 'static w-2/3 flex-1'
          } ${isMobile && sidebarVisible ? 'translate-x-full' : 'translate-x-0'}`}
        >
          <MessageArea
            selectedConversation={selectedConversation}
            messages={messages}
            onSendMessage={handleSendMessage}
            currentUserId={user.id}
            currentUserImage={user.imageUrl}
            onBack={toggleSidebar}
            onTyping={sendTypingStatus}
            isOtherUserTyping={isOtherUserTyping || false}
            initialIsMobile={isMobile}
          />
        </div>
      </div>
      {/*
      <div
        className={`fixed bottom-4 right-4 px-3 py-1 rounded-full text-sm ${webSocketManager.isConnected ? 'bg-green-500'
            : webSocketManager.circuitOpen ? 'bg-orange-500' // Circuit open, might be retrying later
              : 'bg-red-500' // Disconnected, not circuit open
          } text-white`}
      >
        {webSocketManager.isConnected ? (
          'Connected'
        ) : webSocketManager.circuitOpen ? (
          'Connection issues (retrying...)'
        ) : (
          <button
            onClick={webSocketManager.retryConnection}
            className="flex items-center"
          >
            <span>Disconnected</span>
            <span className="ml-2 text-xs">(Click to retry)</span>
          </button>
        )}
      </div>
      */}
      {isAdmin && <AdminTools onDeleteAll={handleDeleteAllConversations} />}
    </div>
  );
};

// Minimal AdminTools component (expand as needed)
const AdminTools = ({ onDeleteAll }: { onDeleteAll: () => void }) => (
  <div className="mt-4 px-4 border-t border-gray-200 py-2">
    <button
      className="px-4 py-2 bg-red-500 rounded-md text-white"
      onClick={onDeleteAll}
    >
      Delete All Conversations
    </button>
  </div>
);

export default MessageInterface;
</file>

<file path="message-route-briefing.md">
# Messageing section of our app

Fetches conversations using server action

Displays them in a converation-list.tsx (ConversationList) with the important caveat that a conversation is created on 3 points (not just two userids) but two userIds and a listingId as we want users to be able to be clear about which property they are communicating about

Connects to websocket using socket.io

Sends messages using socket.io to our (ts_server/server.js) socket server. the socket server passes messaged onto both recipient and our backend for saving to database

Message is caught bia socket.io and client side handlign puts it in the appropriate conversation

BUG! Messages are briefly appearing as doubled upon being caught. I am not sure where this is coming from but I am afraid it might be that we are placing messages into ocnversations based on userIds and not convoId.
</file>

<file path="page.tsx">
import MessageInterface from './message-interface';
import { getAllConversations } from '@/app/actions/conversations';
import { auth, currentUser } from '@clerk/nextjs/server';
import { APP_PAGE_MARGIN } from '@/constants/styles';
import { headers } from 'next/headers';

export default async function MessagePage() {
  let conversations = await getAllConversations();
  let authUser = await currentUser();
  let user = {id: authUser?.id}
  if (!user) {
    return (<p> please log in </p>)
  }
  if (!conversations) {
    conversations = [];
  }

  // Detect mobile device using user-agent
  const headersList = headers();
  const userAgent = headersList.get('user-agent') || '';
  const isMobileDevice = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(userAgent);

  return (
    <div className={` ${APP_PAGE_MARGIN} mx-auto h-[calc(100dvh-75px)]  h-[calc(100dvh-75px)] h-[calc(100dvh-80px)] overflow-hidden`}>
      <MessageInterface conversations={conversations} user={user} initialIsMobile={isMobileDevice} />
    </div>
  );
}
</file>

</files>
