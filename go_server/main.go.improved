package main

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"os"
	"os/signal"
	"runtime"
	"runtime/debug"
	"strings"
	"sync"
	"syscall"
	"time"

	"github.com/gorilla/websocket"
)

// Client represents a connected WebSocket client.
type Client struct {
	ID         string          // Unique client identifier
	UserID     string          // Associated user ID (may differ from ID)
	Conn       *websocket.Conn // WebSocket connection
	Send       chan []byte     // Channel for outgoing messages
	Lock       sync.Mutex      // Protects per-client operations
	closed     bool            // Indicates if the client is closed
	ConnectedAt time.Time      // Time when the client connected
	RemoteAddr  string         // Client's remote address
	UserAgent   string         // Client's user agent
	LastActivity time.Time     // Last activity from this client
}

// Message represents a message exchanged between clients.
type Message struct {
	ID             string    `json:"id,omitempty"`
	ConversationID string    `json:"conversationId,omitempty"`
	SenderID       string    `json:"senderId,omitempty"`
	ReceiverID     string    `json:"receiverId"`
	Content        string    `json:"content"`
	SenderRole     string    `json:"senderRole,omitempty"`
	ImgUrl         string    `json:"imgUrl,omitempty"`
	FileName       string    `json:"fileName,omitempty"`
	FileKey        string    `json:"fileKey,omitempty"`
	FileType       string    `json:"fileType,omitempty"`
	CreatedAt      time.Time `json:"createdAt,omitempty"`
	UpdatedAt      time.Time `json:"updatedAt,omitempty"`
	ClientID       string    `json:"clientId,omitempty"`
	Type           string    `json:"type,omitempty"`
	IsTyping       bool      `json:"isTyping,omitempty"`
	IsRead         bool      `json:"isRead,omitempty"`
	MessageIDs     []string  `json:"messageIds,omitempty"`
	Timestamp      string    `json:"timestamp,omitempty"`
}

// TimedRWMutex wraps sync.RWMutex to log long-held locks.
type TimedRWMutex struct {
	mu sync.RWMutex
}

func (m *TimedRWMutex) Lock() {
	start := time.Now()
	m.mu.Lock()
	if duration := time.Since(start); duration > 100*time.Millisecond {
		log.Printf("WARNING: Lock held for %v", duration)
	}
}

func (m *TimedRWMutex) Unlock() {
	m.mu.Unlock()
}

func (m *TimedRWMutex) RLock() {
	start := time.Now()
	m.mu.RLock()
	if duration := time.Since(start); duration > 100*time.Millisecond {
		log.Printf("WARNING: RLock held for %v", duration)
	}
}

func (m *TimedRWMutex) RUnlock() {
	m.mu.RUnlock()
}

var (
	clients          = make(map[string]*Client) // Map of connected clients
	mutex            = &TimedRWMutex{}          // Global mutex for clients map
	mainServerAPIURL = os.Getenv("MAIN_SERVER_API_URL")
	upgrader         = websocket.Upgrader{
		ReadBufferSize:  1024,
		WriteBufferSize: 1024,
		CheckOrigin: func(r *http.Request) bool {
			// More permissive CORS handling for WebSockets
			// In production, you should limit this to specific origins
			return true
		},
		// Adding additional headers to handle CORS preflight requests
		HandshakeTimeout: 30 * time.Second,
	}
	serverStartTime = time.Now()
	serverVersion   = "2.0.2"
	serverID        = fmt.Sprintf("go-server-%d", time.Now().Unix())
)

func init() {
	if mainServerAPIURL == "" {
		mainServerAPIURL = "http://localhost:3000/api/messages/save"
	}
	log.SetFlags(log.Ldate | log.Ltime | log.Lmicroseconds | log.Lshortfile)
	log.Printf("Server initializing... ID: %s, Version: %s", serverID, serverVersion)
}

// Middleware for error recovery.
func setupErrorHandling(handler http.HandlerFunc) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		defer func() {
			if err := recover(); err != nil {
				stack := string(debug.Stack())
				requestInfo := fmt.Sprintf(
					"Method: %s, URL: %s, RemoteAddr: %s, UserAgent: %s",
					r.Method, r.URL.String(), r.RemoteAddr, r.UserAgent(),
				)
				log.Printf("PANIC RECOVERED:\nRequest: %s\nError: %v\nStack Trace:\n%s", 
					requestInfo, err, stack)
					
				// Try to capture more diagnostic info
				log.Printf("Runtime info: NumGoroutine: %d", runtime.NumGoroutine())
				var memStats runtime.MemStats
				runtime.ReadMemStats(&memStats)
				log.Printf("Memory stats: Alloc=%v MiB, Sys=%v MiB", 
					memStats.Alloc/1024/1024, memStats.Sys/1024/1024)
					
				http.Error(w, "Internal server error", http.StatusInternalServerError)
			}
		}()
		handler(w, r)
	}
}

// Middleware for request logging.
func setupLogging(handler http.HandlerFunc) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		start := time.Now()
		requestID := fmt.Sprintf("req-%d", time.Now().UnixNano())
		
		// Add request ID to context
		ctx := context.WithValue(r.Context(), "requestID", requestID)
		r = r.WithContext(ctx)
		
		log.Printf("[%s] REQUEST: %s %s from %s (User-Agent: %s)", 
			requestID, r.Method, r.URL.Path, r.RemoteAddr, r.UserAgent())
		
		handler(w, r)
		
		duration := time.Since(start)
		log.Printf("[%s] COMPLETED: %s %s in %v", requestID, r.Method, r.URL.Path, duration)
		
		// Log slow requests
		if duration > 500*time.Millisecond {
			log.Printf("[%s] SLOW REQUEST: %s %s took %v", requestID, r.Method, r.URL.Path, duration)
		}
	}
}

func main() {
	log.Printf("Server starting... (version %s - mutex fixes and enhanced debugging)", serverVersion)
	log.Printf("Go version: %s, GOMAXPROCS: %d", runtime.Version(), runtime.GOMAXPROCS(0))
	log.Printf("Main server API URL: %s", mainServerAPIURL)

	http.HandleFunc("/ws", setupLogging(setupErrorHandling(handleWebSocket)))
	http.HandleFunc("/send-message", setupLogging(setupErrorHandling(handleSendMessage)))
	http.HandleFunc("/health-check", setupErrorHandling(func(w http.ResponseWriter, r *http.Request) {
		// Add CORS headers to health check endpoint
		addCorsHeaders(w)
		
		// Handle OPTIONS preflight request
		if r.Method == "OPTIONS" {
			w.WriteHeader(http.StatusOK)
			return
		}
		
		mutex.RLock()
		clientCount := len(clients)
		mutex.RUnlock()
		
		// Get uptime
		uptime := time.Since(serverStartTime)
		
		// Get memory stats
		var memStats runtime.MemStats
		runtime.ReadMemStats(&memStats)
		
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]interface{}{
			"status":       "OK",
			"time":         time.Now().Format(time.RFC3339),
			"connections":  clientCount,
			"version":      serverVersion,
			"server_id":    serverID,
			"uptime":       uptime.String(),
			"goroutines":   runtime.NumGoroutine(),
			"memory_alloc": memStats.Alloc / 1024 / 1024,
			"memory_sys":   memStats.Sys / 1024 / 1024,
		})
	}))
	
	// Add debug endpoint
	http.HandleFunc("/debug", setupLogging(setupErrorHandling(func(w http.ResponseWriter, r *http.Request) {
		// Require admin token
		token := r.URL.Query().Get("token")
		if token != "admin_debug_token" {
			http.Error(w, "Unauthorized", http.StatusUnauthorized)
			return
		}
		
		mutex.RLock()
		clientList := make([]map[string]interface{}, 0, len(clients))
		for id, client := range clients {
			clientInfo := map[string]interface{}{
				"id":             id,
				"connected_at":   client.ConnectedAt.Format(time.RFC3339),
				"last_activity":  client.LastActivity.Format(time.RFC3339),
				"remote_addr":    client.RemoteAddr,
				"user_agent":     client.UserAgent,
				"inactive_for":   time.Since(client.LastActivity).String(),
			}
			clientList = append(clientList, clientInfo)
		}
		mutex.RUnlock()
		
		// Get memory stats
		var memStats runtime.MemStats
		runtime.ReadMemStats(&memStats)
		
		debugInfo := map[string]interface{}{
			"server": map[string]interface{}{
				"version":       serverVersion,
				"id":            serverID,
				"start_time":    serverStartTime.Format(time.RFC3339),
				"uptime":        time.Since(serverStartTime).String(),
				"goroutines":    runtime.NumGoroutine(),
				"memory_alloc":  memStats.Alloc / 1024 / 1024,
				"memory_sys":    memStats.Sys / 1024 / 1024,
				"num_gc":        memStats.NumGC,
				"go_version":    runtime.Version(),
				"gomaxprocs":    runtime.GOMAXPROCS(0),
			},
			"clients": map[string]interface{}{
				"count":     len(clientList),
				"list":      clientList,
			},
		}
		
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(debugInfo)
	})))

	startClientMonitor()
	port := 3001
	server := &http.Server{
		Addr:         fmt.Sprintf(":%d", port),
		ReadTimeout:  30 * time.Second,
		WriteTimeout: 60 * time.Second,
		IdleTimeout:  120 * time.Second,
	}

	stop := make(chan os.Signal, 1)
	signal.Notify(stop, os.Interrupt, syscall.SIGTERM)
	restartServer := make(chan struct{})

	go func() {
		for {
			log.Printf("Starting server on port %d", port)
			if err := server.ListenAndServe(); err != nil && err != http.ErrServerClosed {
				log.Printf("SERVER ERROR: %v", err)
				mutex.Lock()
				for _, client := range clients {
					client.Conn.Close()
					close(client.Send)
				}
				clients = make(map[string]*Client)
				mutex.Unlock()
				time.Sleep(3 * time.Second)
				restartServer <- struct{}{}
			} else {
				break
			}
		}
	}()

	go func() {
		ticker := time.NewTicker(10 * time.Second)
		defer ticker.Stop()
		healthCheckFailCount := 0
		maxFailCount := 3

		for {
			select {
			case <-ticker.C:
				client := http.Client{Timeout: 2 * time.Second}
				_, err := client.Get(fmt.Sprintf("http://localhost:%d/health-check", port))
				if err != nil {
					healthCheckFailCount++
					log.Printf("HEALTH CHECK FAILED (%d/%d): %v", healthCheckFailCount, maxFailCount, err)
					if healthCheckFailCount >= maxFailCount {
						log.Printf("CRITICAL: Restarting after %d failures", maxFailCount)
						mutex.Lock()
						for _, client := range clients {
							client.Conn.Close()
							close(client.Send)
						}
						clients = make(map[string]*Client)
						mutex.Unlock()
						restartServer <- struct{}{}
						healthCheckFailCount = 0
					}
				} else {
					healthCheckFailCount = 0
				}
			case <-stop:
				return
			}
		}
	}()

	select {
	case <-stop:
		log.Println("Received shutdown signal")
	case <-restartServer:
		log.Println("Restart triggered")
	}

	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()
	if err := server.Shutdown(ctx); err != nil {
		log.Printf("Shutdown error: %v", err)
	}

	mutex.Lock()
	for id, client := range clients {
		shutdownMsg, _ := json.Marshal(map[string]interface{}{
			"type":   "connection",
			"status": "server_shutdown",
		})
		client.Conn.WriteMessage(websocket.TextMessage, shutdownMsg)
		client.Conn.Close()
		close(client.Send)
		delete(clients, id)
	}
	mutex.Unlock()
	log.Println("Server shutdown complete")
}

// addCorsHeaders adds CORS headers to the response
func addCorsHeaders(w http.ResponseWriter) {
	w.Header().Set("Access-Control-Allow-Origin", "*")
	w.Header().Set("Access-Control-Allow-Methods", "GET, POST, OPTIONS")
	w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization, X-Requested-With")
	w.Header().Set("Access-Control-Max-Age", "86400") // 24 hours
}

// handleWebSocket manages new WebSocket connections.
func handleWebSocket(w http.ResponseWriter, r *http.Request) {
	requestID := r.Context().Value("requestID").(string)
	
	// Add CORS headers for preflight OPTIONS requests
	if r.Method == "OPTIONS" {
		addCorsHeaders(w)
		w.WriteHeader(http.StatusOK)
		return
	}
	
	log.Printf("[%s] DEBUG: Entered handleWebSocket from %s", requestID, r.RemoteAddr)
	
	// Log full URL and query parameters
	log.Printf("[%s] DEBUG: Full request URL: %s", requestID, r.URL.String())
	log.Printf("[%s] DEBUG: Query parameters: %v", requestID, r.URL.Query())
	
	// Log request headers for debugging
	log.Printf("[%s] DEBUG: Request headers from %s:", requestID, r.RemoteAddr)
	for name, values := range r.Header {
		log.Printf("[%s]   %s: %s", requestID, name, values)
	}
	
	clientID := strings.TrimSpace(r.URL.Query().Get("id"))
	log.Printf("[%s] DEBUG: Client ID extracted: '%s'", requestID, clientID)
	
	// Enhanced validation for client ID
	if clientID == "" {
		log.Printf("[%s] ERROR: Client attempted to connect without an ID", requestID)
		http.Error(w, "Client ID required", http.StatusBadRequest)
		return
	}
	
	// Validate client ID format and log any unusual patterns
	if !strings.HasPrefix(clientID, "user_") && !strings.HasPrefix(clientID, "test_") {
		log.Printf("[%s] WARNING: Unusual client ID format: '%s', proceeding anyway", requestID, clientID)
	}
	
	// Check token length
	if len(clientID) < 10 || len(clientID) > 100 {
		log.Printf("[%s] WARNING: Unusual client ID length (%d): '%s'", requestID, len(clientID), clientID)
	}

	logWithConnCount(fmt.Sprintf("[%s] Connection attempt from client: %s at %s", requestID, clientID, r.RemoteAddr))
	
	log.Printf("[%s] DEBUG: Attempting WebSocket upgrade for %s", requestID, clientID)
	
	// Add CORS headers to response
	addCorsHeaders(w)
	
	// Add additional response headers to help with WebSocket connectivity
	w.Header().Set("Connection", "Upgrade")
	w.Header().Set("Upgrade", "websocket")
	
	conn, err := upgrader.Upgrade(w, r, nil)
	if err != nil {
		log.Printf("[%s] Upgrade error for client %s: %v", requestID, clientID, err)
		// Log specific details about headers to diagnose upgrade issues
		log.Printf("[%s] Origin header: %s", requestID, r.Header.Get("Origin"))
		log.Printf("[%s] Host header: %s", requestID, r.Header.Get("Host")) 
		log.Printf("[%s] Connection header: %s", requestID, r.Header.Get("Connection"))
		log.Printf("[%s] Upgrade header: %s", requestID, r.Header.Get("Upgrade"))
		log.Printf("[%s] Sec-WebSocket-Key header: %s", requestID, r.Header.Get("Sec-WebSocket-Key"))
		log.Printf("[%s] Sec-WebSocket-Version header: %s", requestID, r.Header.Get("Sec-WebSocket-Version"))
		return
	}
	log.Printf("[%s] DEBUG: Upgrade successful for %s", requestID, clientID)

	now := time.Now()
	client := &Client{
		ID:          clientID,
		UserID:      clientID,
		Conn:        conn,
		Send:        make(chan []byte, 256),
		ConnectedAt: now,
		LastActivity: now,
		RemoteAddr:  r.RemoteAddr,
		UserAgent:   r.UserAgent(),
	}

	mutex.Lock()
	if oldClient, exists := clients[clientID]; exists {
		logWithConnCount(fmt.Sprintf("[%s] Replacing existing connection for client: %s", requestID, clientID))
		closeMsg, _ := json.Marshal(map[string]interface{}{
			"type":   "connection",
			"status": "replaced",
		})
		oldClient.Conn.WriteMessage(websocket.TextMessage, closeMsg)
		oldClient.Conn.Close()
		close(oldClient.Send)
	}
	clients[clientID] = client
	mutex.Unlock()

	logWithConnCount(fmt.Sprintf("[%s] New client connected: %s", requestID, clientID))
	
	// Log time in UTC and local timezone to detect any timezone issues
	log.Printf("[%s] Client connected at UTC: %s, Local: %s", 
		requestID, 
		now.UTC().Format(time.RFC3339),
		now.Local().Format(time.RFC3339),
	)
	
	go client.writePump()
	go client.readPump()

	connectionMsg, _ := json.Marshal(map[string]interface{}{
		"type":     "connection",
		"status":   "connected",
		"clientId": clientID,
		"serverId": serverID,
		"version":  serverVersion,
		"time":     now.Format(time.RFC3339),
	})
	client.Send <- connectionMsg
}

// readPump processes incoming messages from a client.
func (c *Client) readPump() {
	clientID := c.ID
	defer func() {
		if r := recover(); r != nil {
			log.Printf("PANIC in readPump for client %s: %v\n%s", clientID, r, debug.Stack())
		}
		c.cleanup()
	}()

	c.Conn.SetReadLimit(512 * 1024)
	c.Conn.SetReadDeadline(time.Now().Add(120 * time.Second))
	c.Conn.SetPongHandler(func(string) error {
		c.Conn.SetReadDeadline(time.Now().Add(120 * time.Second))
		c.LastActivity = time.Now()
		return nil
	})

	consecutiveErrors := 0
	maxConsecutiveErrors := 5
	lastMessageTime := time.Now()
	messageCount := 0

	for {
		if time.Since(lastMessageTime) > 10*time.Minute {
			log.Printf("No messages from client %s for over 10 minutes", clientID)
			break
		}

		_, rawMessage, err := c.Conn.ReadMessage()
		if err != nil {
			consecutiveErrors++
			if websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure, websocket.CloseNormalClosure) {
				log.Printf("WebSocket error for client %s: %v (%d/%d)", clientID, err, consecutiveErrors, maxConsecutiveErrors)
				// Log additional client information on errors
				log.Printf("Client %s details: Connected at %s, RemoteAddr: %s, UserAgent: %s", 
					clientID, c.ConnectedAt.Format(time.RFC3339), c.RemoteAddr, c.UserAgent)
			}
			if consecutiveErrors >= maxConsecutiveErrors {
				log.Printf("Too many errors for client %s, closing", clientID)
				break
			}
			time.Sleep(100 * time.Millisecond)
			continue
		}

		consecutiveErrors = 0
		lastMessageTime = time.Now()
		c.LastActivity = lastMessageTime
		messageCount++
		
		// Log message stats periodically
		if messageCount%100 == 0 {
			log.Printf("Client %s has processed %d messages since connecting", clientID, messageCount)
		}
		
		messageData := make([]byte, len(rawMessage))
		copy(messageData, rawMessage)
		
		// Trace message processing
		requestID := fmt.Sprintf("msg-%s-%d", clientID, time.Now().UnixNano())
		go processIncomingMessage(requestID, c, messageData)
	}
}

// cleanup removes a client from the clients map and closes resources.
func (c *Client) cleanup() {
	clientID := c.ID
	connectionDuration := time.Since(c.ConnectedAt)
	
	c.Lock.Lock()
	c.closed = true
	if c.Conn != nil {
		c.Conn.Close()
	}
	close(c.Send)
	c.Lock.Unlock()

	mutex.Lock()
	if client, exists := clients[clientID]; exists && client.Conn == c.Conn {
		delete(clients, clientID)
		log.Printf("Client disconnected: %s (was connected for %s)", clientID, connectionDuration)
		logWithConnCount(fmt.Sprintf("Client disconnected: %s", clientID))
	}
	mutex.Unlock()
}

// processIncomingMessage handles an incoming message.
func processIncomingMessage(requestID string, c *Client, rawMessage []byte) {
	clientID := c.ID
	start := time.Now()
	defer func() {
		if r := recover(); r != nil {
			log.Printf("[%s] PANIC in message processing for client %s: %v\n%s", 
				requestID, clientID, r, debug.Stack())
		}
		
		duration := time.Since(start)
		if duration > 200*time.Millisecond {
			log.Printf("[%s] SLOW message processing: %v for client %s", 
				requestID, duration, clientID)
		}
	}()
	
	log.Printf("[%s] Processing message from client %s, size: %d bytes", 
		requestID, clientID, len(rawMessage))
		
	var msg Message
	if err := json.Unmarshal(rawMessage, &msg); err != nil {
		log.Printf("[%s] Parse error from client %s: %v", requestID, clientID, err)
		// Log the first 100 bytes of the raw message for debugging
		preview := string(rawMessage)
		if len(preview) > 100 {
			preview = preview[:100] + "..."
		}
		log.Printf("[%s] Invalid message preview: %s", requestID, preview)
		c.Send <- errorJSON(fmt.Sprintf("Invalid message format: %v", err))
		return
	}

	// Track message type
	msgType := msg.Type
	if msgType == "" {
		msgType = "unknown"
	}
	log.Printf("[%s] Message type: %s from client %s", requestID, msgType, clientID)

	if msgType == "ping" {
		resp, _ := json.Marshal(map[string]interface{}{
			"type":       "ping",
			"timestamp":  time.Now().UnixNano() / int64(time.Millisecond),
			"serverTime": time.Now().Format(time.RFC3339),
		})
		c.Send <- resp
		return
	}

	if msg.SenderID == "" {
		msg.SenderID = c.UserID
	}

	if msgType == "typing" || msgType == "read_receipt" {
		if msg.ReceiverID == "" || msg.ConversationID == "" {
			log.Printf("[%s] Invalid %s message: missing receiver or conversation ID", requestID, msgType)
			c.Send <- errorJSON(fmt.Sprintf("Receiver ID and Conversation ID required for %s message", msgType))
			return
		}
		
		deliverMessageToClients(requestID, msg)
		if msgType == "read_receipt" {
			log.Printf("[%s] Sending read receipt to main server", requestID)
			go sendMessageToMainServer(requestID, msg)
		}
		return
	}

	if msg.ReceiverID == "" || msg.ConversationID == "" {
		log.Printf("[%s] Invalid message: missing receiver (%s) or conversation ID (%s)", 
			requestID, msg.ReceiverID, msg.ConversationID)
		c.Send <- errorJSON("Receiver ID and Conversation ID required")
		return
	}

	if msg.CreatedAt.IsZero() {
		msg.CreatedAt = time.Now()
	}
	if msg.UpdatedAt.IsZero() {
		msg.UpdatedAt = time.Now()
	}

	log.Printf("[%s] Delivering message: sender=%s, receiver=%s, conversation=%s", 
		requestID, msg.SenderID, msg.ReceiverID, msg.ConversationID)
		
	deliverySuccess := deliverMessageToClients(requestID, msg)
	if deliverySuccess {
		c.Send <- statusJSON("delivery_status", "delivered", msg.ClientID)
	} else {
		log.Printf("[%s] Delivery failed: receiver not connected", requestID)
	}

	go func() {
		persistStart := time.Now()
		persistSuccess := sendMessageToMainServer(requestID, msg)
		persistDuration := time.Since(persistStart)
		
		if persistDuration > 500*time.Millisecond {
			log.Printf("[%s] SLOW persistence: %v", requestID, persistDuration)
		}
		
		if persistSuccess {
			log.Printf("[%s] Message persisted successfully in %v", requestID, persistDuration)
			c.Send <- statusJSON("persistence_status", "saved", msg.ClientID)
		} else if deliverySuccess {
			log.Printf("[%s] WARNING: Delivered but failed to persist", requestID)
			c.Send <- errorJSONWithID("Message delivered but not saved", msg.ID, msg.ClientID)
		} else {
			log.Printf("[%s] CRITICAL: Message neither delivered nor persisted", requestID)
			c.Send <- errorJSONWithID("Message neither delivered nor saved", msg.ID, msg.ClientID)
		}
	}()
}

// deliverMessageToClients sends a message to matching clients.
func deliverMessageToClients(requestID string, msg Message) bool {
	mutex.RLock()
	var matchingClients []*Client
	targetID := msg.ReceiverID
	for id, client := range clients {
		if strings.EqualFold(id, targetID) {
			matchingClients = append(matchingClients, client)
		}
	}
	mutex.RUnlock()

	if len(matchingClients) == 0 {
		log.Printf("[%s] Receiver not connected: %s", requestID, targetID)
		return false
	}

	messageJSON, err := json.Marshal(msg)
	if err != nil {
		log.Printf("[%s] Marshal error: %v", requestID, err)
		return false
	}

	successCount := 0
	for _, client := range matchingClients {
		client.Lock.Lock()
		if !client.closed {
			select {
			case client.Send <- messageJSON:
				successCount++
				client.LastActivity = time.Now()
			default:
				log.Printf("[%s] Send buffer full for client %s", requestID, client.ID)
			}
		}
		client.Lock.Unlock()
	}

	log.Printf("[%s] Delivered to %d/%d clients", requestID, successCount, len(matchingClients))
	return successCount > 0
}

// sendMessageToMainServer persists a message to the main server.
func sendMessageToMainServer(requestID string, msg Message) bool {
	msgJSON, err := json.Marshal(msg)
	if err != nil {
		log.Printf("[%s] Marshal error: %v", requestID, err)
		return false
	}

	maxRetries := 3
	for attempt := 0; attempt < maxRetries; attempt++ {
		if attempt > 0 {
			retryDelay := time.Second * time.Duration(attempt)
			log.Printf("[%s] Retrying persistence after %v (attempt %d/%d)", 
				requestID, retryDelay, attempt+1, maxRetries)
			time.Sleep(retryDelay)
		}

		ctx, cancel := context.WithTimeout(context.Background(), 15*time.Second)
		defer cancel()
		req, err := http.NewRequestWithContext(ctx, "POST", mainServerAPIURL, bytes.NewBuffer(msgJSON))
		if err != nil {
			log.Printf("[%s] Request creation error: %v", requestID, err)
			continue
		}

		req.Header.Set("Content-Type", "application/json")
		req.Header.Set("X-Request-ID", requestID)
		req.Header.Set("X-Server-ID", serverID)
		client := &http.Client{Timeout: 20 * time.Second}
		
		log.Printf("[%s] Sending persistence request to %s", requestID, mainServerAPIURL)
		
		resp, err := client.Do(req)
		if err != nil {
			log.Printf("[%s] Request error (attempt %d/%d): %v", requestID, attempt+1, maxRetries, err)
			continue
		}

		defer resp.Body.Close()
		if resp.StatusCode == http.StatusOK || resp.StatusCode == http.StatusCreated {
			log.Printf("[%s] Persisted successfully", requestID)
			return true
		}
		
		// Try to read response body for more error details
		respBody := make([]byte, 1024)
		n, _ := resp.Body.Read(respBody)
		log.Printf("[%s] Server error (attempt %d/%d): status=%d, response=%s", 
			requestID, attempt+1, maxRetries, resp.StatusCode, string(respBody[:n]))
	}
	log.Printf("[%s] Failed to persist after %d attempts", requestID, maxRetries)
	return false
}

// writePump sends outgoing messages to a client.
func (c *Client) writePump() {
	clientID := c.ID
	ticker := time.NewTicker(15 * time.Second)
	defer func() {
		if r := recover(); r != nil {
			log.Printf("PANIC in writePump for client %s: %v\n%s", clientID, r, debug.Stack())
		}
		ticker.Stop()
		c.Conn.Close()
	}()

	consecutiveFailures := 0
	maxAllowedFailures := 3
	messagesSent := 0

	for {
		select {
		case message, ok := <-c.Send:
			if !ok {
				c.Conn.WriteMessage(websocket.CloseMessage, []byte{})
				return
			}
			c.Lock.Lock()
			if c.closed {
				c.Lock.Unlock()
				continue
			}
			c.Conn.SetWriteDeadline(time.Now().Add(20 * time.Second))
			err := c.Conn.WriteMessage(websocket.TextMessage, message)
			c.LastActivity = time.Now()
			c.Lock.Unlock()

			messagesSent++
			// Log sending activity periodically
			if messagesSent%100 == 0 {
				log.Printf("Client %s has sent %d messages", clientID, messagesSent)
			}

			if err != nil {
				consecutiveFailures++
				log.Printf("Write error for client %s: %v (%d/%d)", clientID, err, consecutiveFailures, maxAllowedFailures)
				if consecutiveFailures >= maxAllowedFailures {
					log.Printf("Too many write failures for client %s, closing connection", clientID)
					return
				}
			} else {
				consecutiveFailures = 0
			}
		case <-ticker.C:
			c.Lock.Lock()
			if c.closed {
				c.Lock.Unlock()
				continue
			}
			c.Conn.SetWriteDeadline(time.Now().Add(10 * time.Second))
			err := c.Conn.WriteMessage(websocket.PingMessage, nil)
			c.Lock.Unlock()

			if err != nil {
				consecutiveFailures++
				log.Printf("Ping error for client %s: %v (%d/%d)", clientID, err, consecutiveFailures, maxAllowedFailures)
				if consecutiveFailures >= maxAllowedFailures {
					log.Printf("Too many ping failures for client %s, closing connection", clientID)
					return
				}
			} else {
				consecutiveFailures = 0
			}
		}
	}
}

// handleSendMessage handles REST API message sending.
func handleSendMessage(w http.ResponseWriter, r *http.Request) {
	requestID := r.Context().Value("requestID").(string)
	
	if r.Method != http.MethodPost {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	var msg Message
	if err := json.NewDecoder(r.Body).Decode(&msg); err != nil {
		log.Printf("[%s] Decode error: %v", requestID, err)
		http.Error(w, "Invalid request body", http.StatusBadRequest)
		return
	}

	if msg.ReceiverID == "" {
		log.Printf("[%s] Invalid message: missing receiver ID", requestID)
		http.Error(w, "Receiver ID required", http.StatusBadRequest)
		return
	}

	success := deliverMessageToClients(requestID, msg)
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(map[string]interface{}{
		"status":    "Message " + map[bool]string{true: "delivered", false: "received, recipient not connected"}[success],
		"delivered": success,
		"server_id": serverID,
		"request_id": requestID,
	})
}

// Utility functions for common JSON responses.
func errorJSON(message string) []byte {
	data, _ := json.Marshal(map[string]interface{}{
		"type":    "error",
		"message": message,
		"time":    time.Now().Format(time.RFC3339),
	})
	return data
}

func errorJSONWithID(message, msgID, clientID string) []byte {
	data, _ := json.Marshal(map[string]interface{}{
		"type":            "persistence_error",
		"originalMessageId": msgID,
		"clientId":        clientID,
		"message":         message,
		"time":            time.Now().Format(time.RFC3339),
	})
	return data
}

func statusJSON(statusType, status, clientID string) []byte {
	data, _ := json.Marshal(map[string]interface{}{
		"type":      statusType,
		"status":    status,
		"clientId":  clientID,
		"timestamp": time.Now().Format(time.RFC3339),
		"server_id": serverID,
	})
	return data
}

func logWithConnCount(format string, args ...interface{}) {
	mutex.RLock()
	count := len(clients)
	mutex.RUnlock()
	message := fmt.Sprintf(format, args...)
	log.Printf("[Active Connections: %d] %s", count, message)
}

func startClientMonitor() {
	ticker := time.NewTicker(1 * time.Minute)
	go func() {
		iteration := 0
		for range ticker.C {
			iteration++
			mutex.RLock()
			count := len(clients)
			clientAges := make(map[string]time.Duration)
			inactiveClients := 0
			
			for id, client := range clients {
				age := time.Since(client.ConnectedAt)
				inactive := time.Since(client.LastActivity)
				clientAges[id] = age
				
				// Log clients that haven't been active for over 5 minutes
				if inactive > 5*time.Minute {
					inactiveClients++
					log.Printf("INACTIVE CLIENT: %s inactive for %v (connected %v ago)", 
						id, inactive, age)
				}
			}
			mutex.RUnlock()
			
			log.Printf("[CLIENT MONITOR #%d] Connected clients: %d (Inactive: %d)", 
				iteration, count, inactiveClients)
			
			// Log memory stats every 5 iterations
			if iteration%5 == 0 {
				var memStats runtime.MemStats
				runtime.ReadMemStats(&memStats)
				
				log.Printf("[SERVER STATS] Memory: Alloc=%v MiB, Sys=%v MiB, NumGC=%v, Goroutines=%d",
					memStats.Alloc/1024/1024, 
					memStats.Sys/1024/1024, 
					memStats.NumGC,
					runtime.NumGoroutine())
				
				// Check for any very long-lived clients (over 12 hours)
				longLivedClients := 0
				for _, age := range clientAges {
					if age > 12*time.Hour {
						longLivedClients++
					}
				}
				
				if longLivedClients > 0 {
					log.Printf("WARNING: %d clients have been connected for over 12 hours", longLivedClients)
				}
			}
		}
	}()
}